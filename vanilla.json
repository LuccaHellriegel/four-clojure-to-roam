[{"create-time":1614171257633,"edit-time:":1614171257633,"uid":"XfDFBM5rYwK","children":[{"edit-time:":1614171257633,"uid":"U5JsXBLJT3-","string":"**Problems:**","children":[{"edit-time:":1614171257633,"uid":"9xqt7cy13t6","string":"[[4clojure - Problem 1]]"},{"edit-time:":1614171257633,"uid":"Zdn_hoiZKZc","string":"[[4clojure - Problem 2]]"},{"edit-time:":1614171257633,"uid":"knYJRyN8p2_","string":"[[4clojure - Problem 3]]"},{"edit-time:":1614171257633,"uid":"vOk8pzBEVuo","string":"[[4clojure - Problem 4]]"},{"edit-time:":1614171257633,"uid":"ADh-aIXuezH","string":"[[4clojure - Problem 5]]"},{"edit-time:":1614171257633,"uid":"HsdmJxMnY2R","string":"[[4clojure - Problem 6]]"},{"edit-time:":1614171257633,"uid":"K9jfnV1kYjJ","string":"[[4clojure - Problem 7]]"},{"edit-time:":1614171257633,"uid":"IfzJh8eQ2a1","string":"[[4clojure - Problem 8]]"},{"edit-time:":1614171257633,"uid":"LNtsMUcGhEz","string":"[[4clojure - Problem 9]]"},{"edit-time:":1614171257633,"uid":"lDwQEqu7iLp","string":"[[4clojure - Problem 10]]"},{"edit-time:":1614171257633,"uid":"Lw9-ZNnQUJ4","string":"[[4clojure - Problem 11]]"},{"edit-time:":1614171257633,"uid":"aBl-PmgL9zl","string":"[[4clojure - Problem 12]]"},{"edit-time:":1614171257633,"uid":"YyClD2klimR","string":"[[4clojure - Problem 13]]"},{"edit-time:":1614171257633,"uid":"rD5v13AzXxG","string":"[[4clojure - Problem 14]]"},{"edit-time:":1614171257633,"uid":"5BMgTS8rWtd","string":"[[4clojure - Problem 15]]"},{"edit-time:":1614171257633,"uid":"aSYyHO7q6ne","string":"[[4clojure - Problem 16]]"},{"edit-time:":1614171257633,"uid":"JlxzKGO9-ui","string":"[[4clojure - Problem 17]]"},{"edit-time:":1614171257633,"uid":"2irga0mfxyo","string":"[[4clojure - Problem 18]]"},{"edit-time:":1614171257633,"uid":"XQNaNWGUlAP","string":"[[4clojure - Problem 19]]"},{"edit-time:":1614171257633,"uid":"onr7hWndUcj","string":"[[4clojure - Problem 20]]"},{"edit-time:":1614171257633,"uid":"02OOufr4ZY8","string":"[[4clojure - Problem 21]]"},{"edit-time:":1614171257633,"uid":"Wi_doc0Vd0b","string":"[[4clojure - Problem 22]]"},{"edit-time:":1614171257633,"uid":"Z4AFbAiEawR","string":"[[4clojure - Problem 23]]"},{"edit-time:":1614171257633,"uid":"QtPZm5LfDIC","string":"[[4clojure - Problem 24]]"},{"edit-time:":1614171257633,"uid":"ADzWXgh3LIm","string":"[[4clojure - Problem 25]]"},{"edit-time:":1614171257633,"uid":"L31BxVXzoXP","string":"[[4clojure - Problem 26]]"},{"edit-time:":1614171257633,"uid":"uYcNDOZLoVV","string":"[[4clojure - Problem 27]]"},{"edit-time:":1614171257633,"uid":"pr0nPh4KftN","string":"[[4clojure - Problem 28]]"},{"edit-time:":1614171257633,"uid":"BE8cfDER_EY","string":"[[4clojure - Problem 29]]"},{"edit-time:":1614171257633,"uid":"QN0sDDRx5YU","string":"[[4clojure - Problem 30]]"},{"edit-time:":1614171257633,"uid":"JIqxInKrbC0","string":"[[4clojure - Problem 31]]"},{"edit-time:":1614171257633,"uid":"Csv3KQVPoXc","string":"[[4clojure - Problem 32]]"},{"edit-time:":1614171257633,"uid":"2-M3g86CeNc","string":"[[4clojure - Problem 33]]"},{"edit-time:":1614171257633,"uid":"NV9q-9DSOGa","string":"[[4clojure - Problem 34]]"},{"edit-time:":1614171257633,"uid":"q0loJ_tw-zH","string":"[[4clojure - Problem 35]]"},{"edit-time:":1614171257633,"uid":"zZJob8A5Byx","string":"[[4clojure - Problem 36]]"},{"edit-time:":1614171257633,"uid":"69aKu8zkZkW","string":"[[4clojure - Problem 37]]"},{"edit-time:":1614171257633,"uid":"fvH9Iekcpql","string":"[[4clojure - Problem 38]]"},{"edit-time:":1614171257633,"uid":"99kfLByHXXO","string":"[[4clojure - Problem 39]]"},{"edit-time:":1614171257633,"uid":"87-poMrQzJB","string":"[[4clojure - Problem 40]]"},{"edit-time:":1614171257633,"uid":"vQAmP8p1XjV","string":"[[4clojure - Problem 41]]"},{"edit-time:":1614171257633,"uid":"GmUAQ5JJkOX","string":"[[4clojure - Problem 42]]"},{"edit-time:":1614171257633,"uid":"WO-5Wa0ycUV","string":"[[4clojure - Problem 43]]"},{"edit-time:":1614171257633,"uid":"xOZ_L_BRcuZ","string":"[[4clojure - Problem 44]]"},{"edit-time:":1614171257633,"uid":"92c8_4nkLaY","string":"[[4clojure - Problem 45]]"},{"edit-time:":1614171257633,"uid":"XRy4F8jiUOF","string":"[[4clojure - Problem 46]]"},{"edit-time:":1614171257633,"uid":"f7SN4w8Cjet","string":"[[4clojure - Problem 47]]"},{"edit-time:":1614171257633,"uid":"vFOg0rU5G50","string":"[[4clojure - Problem 48]]"},{"edit-time:":1614171257633,"uid":"q1I-l5JqKd7","string":"[[4clojure - Problem 49]]"},{"edit-time:":1614171257633,"uid":"SAo5Vvabxab","string":"[[4clojure - Problem 50]]"},{"edit-time:":1614171257633,"uid":"mqB0s08rxtB","string":"[[4clojure - Problem 51]]"},{"edit-time:":1614171257633,"uid":"Sy592f9V1_5","string":"[[4clojure - Problem 52]]"},{"edit-time:":1614171257633,"uid":"K6Gw-yjw939","string":"[[4clojure - Problem 53]]"},{"edit-time:":1614171257633,"uid":"zSUUz_0DN_u","string":"[[4clojure - Problem 54]]"},{"edit-time:":1614171257633,"uid":"YGc2ldprfW2","string":"[[4clojure - Problem 55]]"},{"edit-time:":1614171257633,"uid":"GQN30tGHedX","string":"[[4clojure - Problem 56]]"},{"edit-time:":1614171257633,"uid":"NlfDW_0B207","string":"[[4clojure - Problem 57]]"},{"edit-time:":1614171257633,"uid":"fglGui4XzH0","string":"[[4clojure - Problem 58]]"},{"edit-time:":1614171257633,"uid":"LWJ8VZv2YeF","string":"[[4clojure - Problem 59]]"},{"edit-time:":1614171257633,"uid":"IvVdNeK5tBy","string":"[[4clojure - Problem 60]]"},{"edit-time:":1614171257633,"uid":"jI5PncWU_68","string":"[[4clojure - Problem 61]]"},{"edit-time:":1614171257633,"uid":"jZ3XuZ2BdOl","string":"[[4clojure - Problem 62]]"},{"edit-time:":1614171257633,"uid":"z1SRSUrVnwV","string":"[[4clojure - Problem 63]]"},{"edit-time:":1614171257633,"uid":"ecKq7laWvTa","string":"[[4clojure - Problem 64]]"},{"edit-time:":1614171257633,"uid":"bsy5wqR61yr","string":"[[4clojure - Problem 65]]"},{"edit-time:":1614171257633,"uid":"Vkb8xweZTzU","string":"[[4clojure - Problem 66]]"},{"edit-time:":1614171257633,"uid":"_p6asP5PAEh","string":"[[4clojure - Problem 67]]"},{"edit-time:":1614171257633,"uid":"qg_ZNpYXyv5","string":"[[4clojure - Problem 68]]"},{"edit-time:":1614171257633,"uid":"NyCuuFjic6q","string":"[[4clojure - Problem 69]]"},{"edit-time:":1614171257633,"uid":"3E3DywIictJ","string":"[[4clojure - Problem 70]]"},{"edit-time:":1614171257633,"uid":"mNDDyO4N5jU","string":"[[4clojure - Problem 71]]"},{"edit-time:":1614171257633,"uid":"XRGKP5Ism7t","string":"[[4clojure - Problem 72]]"},{"edit-time:":1614171257633,"uid":"936Q6w4KlZ-","string":"[[4clojure - Problem 73]]"},{"edit-time:":1614171257633,"uid":"XAnhyNTTWDM","string":"[[4clojure - Problem 74]]"},{"edit-time:":1614171257633,"uid":"GMRLGUC5fEh","string":"[[4clojure - Problem 75]]"},{"edit-time:":1614171257633,"uid":"309tX_1DsVy","string":"[[4clojure - Problem 76]]"},{"edit-time:":1614171257633,"uid":"aW8qhP3h-08","string":"[[4clojure - Problem 77]]"},{"edit-time:":1614171257633,"uid":"3QwCIEgnmT9","string":"[[4clojure - Problem 78]]"},{"edit-time:":1614171257633,"uid":"bBdjSWXMZa2","string":"[[4clojure - Problem 79]]"},{"edit-time:":1614171257633,"uid":"o5raXsBnWhK","string":"[[4clojure - Problem 80]]"},{"edit-time:":1614171257633,"uid":"e3bqk_uL8fk","string":"[[4clojure - Problem 81]]"},{"edit-time:":1614171257633,"uid":"FeY7_E-SyYH","string":"[[4clojure - Problem 82]]"},{"edit-time:":1614171257633,"uid":"9DXzCwvigmi","string":"[[4clojure - Problem 83]]"},{"edit-time:":1614171257633,"uid":"h4k_nMHkHts","string":"[[4clojure - Problem 84]]"},{"edit-time:":1614171257633,"uid":"4SnAoOiPI4z","string":"[[4clojure - Problem 85]]"},{"edit-time:":1614171257633,"uid":"N69h-YdUEhn","string":"[[4clojure - Problem 86]]"},{"edit-time:":1614171257633,"uid":"63fwhJTemhO","string":"[[4clojure - Problem 88]]"},{"edit-time:":1614171257633,"uid":"n6JkbJhOFC6","string":"[[4clojure - Problem 89]]"},{"edit-time:":1614171257633,"uid":"Fqd33HDruET","string":"[[4clojure - Problem 90]]"},{"edit-time:":1614171257633,"uid":"4hmlXSVZ44g","string":"[[4clojure - Problem 91]]"},{"edit-time:":1614171257633,"uid":"73ezmAdZ0ME","string":"[[4clojure - Problem 92]]"},{"edit-time:":1614171257633,"uid":"hnO6mly-i9y","string":"[[4clojure - Problem 93]]"},{"edit-time:":1614171257633,"uid":"2etwNNPAeAS","string":"[[4clojure - Problem 94]]"},{"edit-time:":1614171257633,"uid":"7tOrQ11fRqh","string":"[[4clojure - Problem 95]]"},{"edit-time:":1614171257633,"uid":"pT3G7imLAhT","string":"[[4clojure - Problem 96]]"},{"edit-time:":1614171257633,"uid":"Mg3RCVwKAy0","string":"[[4clojure - Problem 97]]"},{"edit-time:":1614171257633,"uid":"n-2EnocMQLO","string":"[[4clojure - Problem 98]]"},{"edit-time:":1614171257633,"uid":"Zd4gLEgAeN9","string":"[[4clojure - Problem 99]]"},{"edit-time:":1614171257633,"uid":"WhkC_X3qfid","string":"[[4clojure - Problem 100]]"},{"edit-time:":1614171257633,"uid":"4oV3oQdU3d5","string":"[[4clojure - Problem 101]]"},{"edit-time:":1614171257633,"uid":"kRXspVFcxy8","string":"[[4clojure - Problem 102]]"},{"edit-time:":1614171257633,"uid":"__bsDkwAYxM","string":"[[4clojure - Problem 103]]"},{"edit-time:":1614171257633,"uid":"3uxHViAhUUi","string":"[[4clojure - Problem 104]]"},{"edit-time:":1614171257633,"uid":"ch1uzB_vniD","string":"[[4clojure - Problem 105]]"},{"edit-time:":1614171257633,"uid":"lRyOF1yguwN","string":"[[4clojure - Problem 106]]"},{"edit-time:":1614171257633,"uid":"4-gIRhOghz7","string":"[[4clojure - Problem 107]]"},{"edit-time:":1614171257633,"uid":"tsdxwGWjWvC","string":"[[4clojure - Problem 108]]"},{"edit-time:":1614171257633,"uid":"Q4rjlcIcLEl","string":"[[4clojure - Problem 110]]"},{"edit-time:":1614171257633,"uid":"rn7Upqav-WO","string":"[[4clojure - Problem 111]]"},{"edit-time:":1614171257633,"uid":"7kTGwCAYcu2","string":"[[4clojure - Problem 112]]"},{"edit-time:":1614171257633,"uid":"LCyN2tt7B12","string":"[[4clojure - Problem 113]]"},{"edit-time:":1614171257633,"uid":"4CfelmmxXda","string":"[[4clojure - Problem 114]]"},{"edit-time:":1614171257633,"uid":"btNvSXfij_k","string":"[[4clojure - Problem 115]]"},{"edit-time:":1614171257633,"uid":"DF2t7KMIYqX","string":"[[4clojure - Problem 116]]"},{"edit-time:":1614171257633,"uid":"v-JdI6mICpR","string":"[[4clojure - Problem 117]]"},{"edit-time:":1614171257633,"uid":"vrnhbRN5sNS","string":"[[4clojure - Problem 118]]"},{"edit-time:":1614171257633,"uid":"s8Fl1YTxosq","string":"[[4clojure - Problem 119]]"},{"edit-time:":1614171257633,"uid":"u_DzhlCWNvC","string":"[[4clojure - Problem 120]]"},{"edit-time:":1614171257633,"uid":"HjNQ3sY6fzp","string":"[[4clojure - Problem 121]]"},{"edit-time:":1614171257633,"uid":"a87BTU-scrH","string":"[[4clojure - Problem 122]]"},{"edit-time:":1614171257633,"uid":"VUlVAzl8HoA","string":"[[4clojure - Problem 124]]"},{"edit-time:":1614171257633,"uid":"ofaz90E0zrS","string":"[[4clojure - Problem 125]]"},{"edit-time:":1614171257633,"uid":"xU1NBDKYzt5","string":"[[4clojure - Problem 126]]"},{"edit-time:":1614171257633,"uid":"waVuhXP9D4O","string":"[[4clojure - Problem 127]]"},{"edit-time:":1614171257633,"uid":"fhhEhXYkjG_","string":"[[4clojure - Problem 128]]"},{"edit-time:":1614171257633,"uid":"ayr-vEADAsI","string":"[[4clojure - Problem 130]]"},{"edit-time:":1614171257633,"uid":"oMsrrSFqe5n","string":"[[4clojure - Problem 131]]"},{"edit-time:":1614171257633,"uid":"MTs2D2RyeQn","string":"[[4clojure - Problem 132]]"},{"edit-time:":1614171257633,"uid":"FSv9nC_uRMe","string":"[[4clojure - Problem 134]]"},{"edit-time:":1614171257633,"uid":"D2GUHNbicrH","string":"[[4clojure - Problem 135]]"},{"edit-time:":1614171257633,"uid":"iqnet583pVM","string":"[[4clojure - Problem 137]]"},{"edit-time:":1614171257633,"uid":"azPkXR8RNg2","string":"[[4clojure - Problem 138]]"},{"edit-time:":1614171257633,"uid":"IRgF-F6DVDy","string":"[[4clojure - Problem 140]]"},{"edit-time:":1614171257633,"uid":"EnH3iykBHVT","string":"[[4clojure - Problem 141]]"},{"edit-time:":1614171257633,"uid":"xELlh6dJaH-","string":"[[4clojure - Problem 143]]"},{"edit-time:":1614171257633,"uid":"6-2VmqM1W0a","string":"[[4clojure - Problem 144]]"},{"edit-time:":1614171257633,"uid":"s4SxhneE-bZ","string":"[[4clojure - Problem 145]]"},{"edit-time:":1614171257633,"uid":"j5T4Isx4-TW","string":"[[4clojure - Problem 146]]"},{"edit-time:":1614171257633,"uid":"5ejWXT-ITJo","string":"[[4clojure - Problem 147]]"},{"edit-time:":1614171257633,"uid":"LhVHhJ5EHQ6","string":"[[4clojure - Problem 148]]"},{"edit-time:":1614171257633,"uid":"GnkJWPwptIY","string":"[[4clojure - Problem 150]]"},{"edit-time:":1614171257633,"uid":"_xIY_a_zVw8","string":"[[4clojure - Problem 152]]"},{"edit-time:":1614171257633,"uid":"YSeePgKYX56","string":"[[4clojure - Problem 153]]"},{"edit-time:":1614171257633,"uid":"PoHM029Xzgy","string":"[[4clojure - Problem 156]]"}]}],"title":"4clojure - Problems"},{"create-time":1614171257609,"edit-time:":1614171257609,"uid":"Hqyhmwmayl5","children":[{"edit-time:":1614171257609,"uid":"KwdKHOaLmoZ","string":"**URL:** https://www.4clojure.com/problem/1"},{"edit-time:":1614171257609,"uid":"e0OiB5CFPKK","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257609,"uid":"X4Q5nRgNMx_","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257610,"uid":"IQWXEPUvhod","string":"**Syntax**:","children":[{"edit-time:":1614171257610,"uid":"RigXME5SRmj","string":"```clojure\n(= ...)```"},{"edit-time:":1614171257610,"uid":"dcHDK5vYfRA","string":"```clojure\n(not ...)```"}]},{"edit-time:":1614171257610,"uid":"-7SzgSD5IAA","string":"**Problem:**","children":[{"edit-time:":1614171257610,"uid":"P9mmLWmWvHY","string":"```clojure\n; This is a clojure form.\n; Enter a value which will make the form evaluate to true.\n; Don't over think it! If you are confused, see the getting started page.\n; Hint: true is equal to true.\n\n(= __ true)```"}]}],"title":"4clojure - Problem 1"},{"create-time":1614171257610,"edit-time:":1614171257610,"uid":"UQryscpbTQz","children":[{"edit-time:":1614171257610,"uid":"xXYmkWAJdix","string":"**URL:** https://www.4clojure.com/problem/2"},{"edit-time:":1614171257610,"uid":"nYGvY9L9uAO","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257610,"uid":"F-8v9lw4Va7","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257610,"uid":"zMQhppd26aP","string":"**Syntax**:","children":[{"edit-time:":1614171257610,"uid":"fOnSzX0ozdr","string":"```clojure\n(* ...)```"}]},{"edit-time:":1614171257610,"uid":"EsrNoYpN_9p","string":"**Problem:**","children":[{"edit-time:":1614171257610,"uid":"iEbHkzchTH6","string":"```clojure\n; If you are not familiar with polish notation, simple arithmetic might seem confusing.\n; \n; Note: Enter only enough to fill in the blank (in this case, a single number) - do not retype the whole problem.\n\n(= (- 10 (* 2 3)) __)```"}]}],"title":"4clojure - Problem 2"},{"create-time":1614171257610,"edit-time:":1614171257610,"uid":"qApj1t0Qdg9","children":[{"edit-time:":1614171257610,"uid":"d7Muyr5fbqc","string":"**URL:** https://www.4clojure.com/problem/3"},{"edit-time:":1614171257610,"uid":"RGxCXp1yOj-","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257610,"uid":"_ihOIvdwmQC","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257610,"uid":"N9pVE8DbogG","string":"**Problem:**","children":[{"edit-time:":1614171257610,"uid":"ZL4v1h117d8","string":"```clojure\n; Clojure strings are Java strings.\n; This means that you can use any of the Java string methods on Clojure strings.\n\n(= __ (.toUpperCase \"hello world\"))```"}]}],"title":"4clojure - Problem 3"},{"create-time":1614171257610,"edit-time:":1614171257610,"uid":"hEb2WEzVbYH","children":[{"edit-time:":1614171257610,"uid":"v1MpPz5IMV0","string":"**URL:** https://www.4clojure.com/problem/4"},{"edit-time:":1614171257610,"uid":"-mhXP_QhqpL","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257610,"uid":"wjMC51C4b-L","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257610,"uid":"Py4r0L171JW","string":"**Syntax**:","children":[{"edit-time:":1614171257610,"uid":"PmHRL2WlLGA","string":"```clojure\n(list ...)```"}]},{"edit-time:":1614171257610,"uid":"8D2ElsaC6Vw","string":"**Problem:**","children":[{"edit-time:":1614171257610,"uid":"RJtBVmIPDEW","string":"```clojure\n; Lists can be constructed with either a function or a quoted form.\n\n(= (list __) '(:a :b :c))```"}]}],"title":"4clojure - Problem 4"},{"create-time":1614171257610,"edit-time:":1614171257610,"uid":"jswA95Jq8KS","children":[{"edit-time:":1614171257610,"uid":"MBQGXT5YH4w","string":"**URL:** https://www.4clojure.com/problem/5"},{"edit-time:":1614171257610,"uid":"Mhp6C5_4qSr","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257610,"uid":"rVeexOe-fVi","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257610,"uid":"ud3HxPpGI1w","string":"**Syntax**:","children":[{"edit-time:":1614171257610,"uid":"SBo0Q5p48xY","string":"```clojure\n(conj ...)```"}]},{"edit-time:":1614171257610,"uid":"tEmkjEuui6M","string":"**Problem:**","children":[{"edit-time:":1614171257610,"uid":"XHbHQnckitG","string":"```clojure\n; When operating on a list, the conj function will return a new list with one or more items \"added\" to the front.\n; \n; Note that there are two test cases, but you are expected to supply only one answer, which will cause all the tests to pass.\n\n(= __ (conj '(2 3 4) 1))\n\n\t\n(= __ (conj '(3 4) 2 1))```"}]}],"title":"4clojure - Problem 5"},{"create-time":1614171257610,"edit-time:":1614171257610,"uid":"gsi-KuIFYCD","children":[{"edit-time:":1614171257610,"uid":"C7fYT_q0axg","string":"**URL:** https://www.4clojure.com/problem/6"},{"edit-time:":1614171257610,"uid":"7KcHd5MZWPz","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257610,"uid":"2YkpfbhfwRA","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257610,"uid":"HksdwCJvXr0","string":"**Syntax**:","children":[{"edit-time:":1614171257610,"uid":"cJd0P3KYcTy","string":"```clojure\n(vec ...)```"},{"edit-time:":1614171257610,"uid":"1fWfC3IgxI-","string":"```clojure\n(vector ...)```"}]},{"edit-time:":1614171257610,"uid":"RYqrfisbbcm","string":"**Problem:**","children":[{"edit-time:":1614171257610,"uid":"ZHF0NzM0XJz","string":"```clojure\n; Vectors can be constructed several ways.\n; You can compare them with lists.\n; \n; \n; Note: the brackets [] surrounding the blanks __ are part of the test case.\n\n(= [__] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))```"}]}],"title":"4clojure - Problem 6"},{"create-time":1614171257610,"edit-time:":1614171257610,"uid":"oBNrdiz8eg7","children":[{"edit-time:":1614171257610,"uid":"NqSJDrWSg5A","string":"**URL:** https://www.4clojure.com/problem/7"},{"edit-time:":1614171257610,"uid":"Ckt-_kHcAbY","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257610,"uid":"k1Vs-D8y7Fl","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257610,"uid":"d1GrhiR37AY","string":"**Problem:**","children":[{"edit-time:":1614171257610,"uid":"i3OgAewIwgt","string":"```clojure\n; When operating on a Vector, the conj function will return a new vector with one or more items \"added\" to the end.\n\n(= __ (conj [1 2 3] 4))\n\n\t\n(= __ (conj [1 2] 3 4))```"}]}],"title":"4clojure - Problem 7"},{"create-time":1614171257610,"edit-time:":1614171257610,"uid":"3x7w3_rfjvF","children":[{"edit-time:":1614171257610,"uid":"vPW77I-2Viu","string":"**URL:** https://www.4clojure.com/problem/8"},{"edit-time:":1614171257610,"uid":"MX--SQrgXtH","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257610,"uid":"Jv4MfO13iCj","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257610,"uid":"jKRll4Zkh1A","string":"**Syntax**:","children":[{"edit-time:":1614171257610,"uid":"nQ95LvjFn7C","string":"```clojure\n(set ...)```"}]},{"edit-time:":1614171257610,"uid":"ZI30LIBeyGL","string":"**Problem:**","children":[{"edit-time:":1614171257610,"uid":"uXB1VzPpbIJ","string":"```clojure\n; Sets are collections of unique values.\n\n(= __ (set '(:a :a :b :c :c :c :c :d :d)))\n\n\t\n(= __ (clojure.set/union #{:a :b :c} #{:b :c :d}))```"}]}],"title":"4clojure - Problem 8"},{"create-time":1614171257610,"edit-time:":1614171257610,"uid":"9kIzGi9N9uZ","children":[{"edit-time:":1614171257610,"uid":"Hm78f9cCM0V","string":"**URL:** https://www.4clojure.com/problem/9"},{"edit-time:":1614171257610,"uid":"_XhfW7Dd6_w","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257610,"uid":"q9Gx1NfIEaL","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257610,"uid":"dbt1ki3YMMj","string":"**Problem:**","children":[{"edit-time:":1614171257610,"uid":"A4tdMKJGdCe","string":"```clojure\n; When operating on a set, the conj function returns a new set with one or more keys \"added\".\n\n(= #{1 2 3 4} (conj #{1 4 3} __))```"}]}],"title":"4clojure - Problem 9"},{"create-time":1614171257610,"edit-time:":1614171257610,"uid":"-owstftpXjg","children":[{"edit-time:":1614171257610,"uid":"u7p0-xvdulN","string":"**URL:** https://www.4clojure.com/problem/10"},{"edit-time:":1614171257610,"uid":"KhMKBX0qGC_","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257610,"uid":"xoLKw4L4vBF","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257612,"uid":"dT4eYXGfei3","string":"**Syntax**:","children":[{"edit-time:":1614171257612,"uid":"M50OfKktamO","string":"```clojure\n(hash-map ...)```"}]},{"edit-time:":1614171257612,"uid":"LcuEZ1Vd-gM","string":"**Problem:**","children":[{"edit-time:":1614171257612,"uid":"6nP3Fb0CehV","string":"```clojure\n; Maps store key-value pairs.\n; Both maps and keywords can be used as lookup functions.\n; Commas can be used to make maps more readable, but they are not required.\n\n(= __ ((hash-map :a 10, :b 20, :c 30) :b))\n\n\t\n(= __ (:b {:a 10, :b 20, :c 30}))```"}]}],"title":"4clojure - Problem 10"},{"create-time":1614171257612,"edit-time:":1614171257612,"uid":"6H-xi5Pfj9G","children":[{"edit-time:":1614171257612,"uid":"FObsoMW-gsM","string":"**URL:** https://www.4clojure.com/problem/11"},{"edit-time:":1614171257612,"uid":"-u2xmlt_zRz","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257612,"uid":"m-deBMcKv9C","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257612,"uid":"QaRGC7wU1rw","string":"**Problem:**","children":[{"edit-time:":1614171257612,"uid":"zOSBegjmg_I","string":"```clojure\n; When operating on a map, the conj function returns a new map with one or more key-value pairs \"added\".\n\n(= {:a 1, :b 2, :c 3} (conj {:a 1} __ [:c 3]))```"}]}],"title":"4clojure - Problem 11"},{"create-time":1614171257612,"edit-time:":1614171257612,"uid":"0IfCRrgl8cC","children":[{"edit-time:":1614171257612,"uid":"Db2iLwiPaUX","string":"**URL:** https://www.4clojure.com/problem/12"},{"edit-time:":1614171257612,"uid":"TiVO5-st_Yh","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257612,"uid":"YZahUwLBsk7","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257612,"uid":"XqbmPtJTAhu","string":"**Syntax**:","children":[{"edit-time:":1614171257612,"uid":"XkrBtarY2ef","string":"```clojure\n(first ...)```"},{"edit-time:":1614171257612,"uid":"fu1TYV4Ku-W","string":"```clojure\n(second ...)```"},{"edit-time:":1614171257612,"uid":"0EhWUnnhSRd","string":"```clojure\n(last ...)```"}]},{"edit-time:":1614171257612,"uid":"-24XQB2tiGv","string":"**Problem:**","children":[{"edit-time:":1614171257612,"uid":"jaM95eTqz0n","string":"```clojure\n; All Clojure collections support sequencing.\n; You can operate on sequences with functions like first, second, and last.\n\n(= __ (first '(3 2 1)))\n\n\t\n(= __ (second [2 3 4]))\n\n\t\n(= __ (last (list 1 2 3)))```"}]}],"title":"4clojure - Problem 12"},{"create-time":1614171257612,"edit-time:":1614171257612,"uid":"Mf8ZoVHA-pz","children":[{"edit-time:":1614171257612,"uid":"APgQmurrl8S","string":"**URL:** https://www.4clojure.com/problem/13"},{"edit-time:":1614171257612,"uid":"HTY2jB1m2Mt","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257612,"uid":"w7ojOBpxCmZ","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257612,"uid":"0948N8u-4Vh","string":"**Syntax**:","children":[{"edit-time:":1614171257612,"uid":"d6UbIO3G4o8","string":"```clojure\n(rest ...)```"}]},{"edit-time:":1614171257612,"uid":"hWLkHhqISwA","string":"**Problem:**","children":[{"edit-time:":1614171257612,"uid":"GTFpPBLedsJ","string":"```clojure\n; The rest function will return all the items of a sequence except the first.\n\n(= __ (rest [10 20 30 40]))```"}]}],"title":"4clojure - Problem 13"},{"create-time":1614171257612,"edit-time:":1614171257612,"uid":"4QWIZGhxNab","children":[{"edit-time:":1614171257612,"uid":"4buRntL96WA","string":"**URL:** https://www.4clojure.com/problem/14"},{"edit-time:":1614171257612,"uid":"TDumzKqPWLZ","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257612,"uid":"oPWBKEEIrQq","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257612,"uid":"Tt6DbbcDQCV","string":"**Syntax**:","children":[{"edit-time:":1614171257612,"uid":"WIVq_BmsVa8","string":"```clojure\n(fn ...)```"},{"edit-time:":1614171257612,"uid":"sF_87UNIYfc","string":"```clojure\n(partial ...)```"}]},{"edit-time:":1614171257612,"uid":"0XiWTcM8Gst","string":"**Problem:**","children":[{"edit-time:":1614171257612,"uid":"VFWPuoi1iI9","string":"```clojure\n; Clojure has many different ways to create functions.\n\n(= __ ((fn add-five [x] (+ x 5)) 3))\n\n\t\n(= __ ((fn [x] (+ x 5)) 3))\n\n\t\n(= __ (#(+ % 5) 3))\n\n\t\n(= __ ((partial + 5) 3))```"}]}],"title":"4clojure - Problem 14"},{"create-time":1614171257612,"edit-time:":1614171257612,"uid":"s70sX6P-9jz","children":[{"edit-time:":1614171257612,"uid":"psE60UyHBew","string":"**URL:** https://www.4clojure.com/problem/15"},{"edit-time:":1614171257612,"uid":"qVphFx4K84m","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257612,"uid":"d8rPOuTXxjM","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257612,"uid":"_NdjgSCvTj4","string":"**Problem:**","children":[{"edit-time:":1614171257612,"uid":"vUOduLN7LVT","string":"```clojure\n; Write a function which doubles a number.\n\n(= (__ 2) 4)\n\n\t\n(= (__ 3) 6)\n\n\t\n(= (__ 11) 22)\n\n\t\n(= (__ 7) 14)```"}]}],"title":"4clojure - Problem 15"},{"create-time":1614171257612,"edit-time:":1614171257612,"uid":"snuHtE2QvGb","children":[{"edit-time:":1614171257612,"uid":"a2Y8i8nSMHo","string":"**URL:** https://www.4clojure.com/problem/16"},{"edit-time:":1614171257613,"uid":"z6FKaEbz9i2","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"NBpLKDjtE9O","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257613,"uid":"kcRm7abI0Jw","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"Z1fVdh-LMP4","string":"```clojure\n; Write a function which returns a personalized greeting.\n\n(= (__ \"Dave\") \"Hello, Dave!\")\n\n\t\n(= (__ \"Jenn\") \"Hello, Jenn!\")\n\n\t\n(= (__ \"Rhea\") \"Hello, Rhea!\")```"}]}],"title":"4clojure - Problem 16"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"Y3l1PzxpHlT","children":[{"edit-time:":1614171257613,"uid":"CAxZ4zLXV0V","string":"**URL:** https://www.4clojure.com/problem/17"},{"edit-time:":1614171257613,"uid":"T9kMVG91IVo","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"Wp5FcIanofr","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257613,"uid":"EiJBmM07it8","string":"**Syntax**:","children":[{"edit-time:":1614171257613,"uid":"b4lXUA1MOM2","string":"```clojure\n(map ...)```"}]},{"edit-time:":1614171257613,"uid":"7fc6Jrf5Jd6","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"Kxwe96aydWi","string":"```clojure\n; The map function takes two arguments: a function (f) and a sequence (s).\n; Map returns a new sequence consisting of the result of applying f to each item of s.\n; Do not confuse the map function with the map data structure.\n\n(= __ (map #(+ % 5) '(1 2 3)))```"}]}],"title":"4clojure - Problem 17"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"CZmxs1QxJ3C","children":[{"edit-time:":1614171257613,"uid":"U_Fx_VMMLVA","string":"**URL:** https://www.4clojure.com/problem/18"},{"edit-time:":1614171257613,"uid":"7Vfw_rlkDPu","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"3CfsZIC23Bw","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257613,"uid":"W4vPIcDr2l8","string":"**Syntax**:","children":[{"edit-time:":1614171257613,"uid":"GXB8ZEaFwqN","string":"```clojure\n(filter ...)```"},{"edit-time:":1614171257613,"uid":"wiZJGaURjGH","string":"```clojure\n(> ...)```"}]},{"edit-time:":1614171257613,"uid":"YXyuj-DKBbF","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"l8pipsKb-Mu","string":"```clojure\n; The filter function takes two arguments: a predicate function (f) and a sequence (s).\n; Filter returns a new sequence consisting of all the items of s for which (f item) returns true.\n\n(= __ (filter #(> % 5) '(3 4 5 6 7)))```"}]}],"title":"4clojure - Problem 18"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"EYE1MevOob6","children":[{"edit-time:":1614171257613,"uid":"9fZ0A_lRszp","string":"**URL:** https://www.4clojure.com/problem/19"},{"edit-time:":1614171257613,"uid":"lfWk8cKoljk","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"bntr10XjW2-","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"fQyQPEwhuah","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257613,"uid":"n9hrrvvVQ6B","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"kg16AcC9qSp","string":"```clojure\n; Write a function which returns the last element in a sequence.\n\n; Special Restrictions:\n; last\n\n(= (__ [1 2 3 4 5]) 5)\n\n\t\n(= (__ '(5 4 3)) 3)\n\n\t\n(= (__ [\"b\" \"c\" \"d\"]) \"d\")```"}]}],"title":"4clojure - Problem 19"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"T4PYYzLpdU-","children":[{"edit-time:":1614171257613,"uid":"6sEnZmXeNUj","string":"**URL:** https://www.4clojure.com/problem/20"},{"edit-time:":1614171257613,"uid":"Ziv6ud3EKuN","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"cCFmCzotMp_","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"cdUzdJfPjj5","string":"Topics: seqs"}]},{"edit-time:":1614171257613,"uid":"tVClDBLMVyB","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"KXU8MWh_fWk","string":"```clojure\n; Write a function which returns the second to last element from a sequence.\n\n(= (__ (list 1 2 3 4 5)) 4)\n\n\t\n(= (__ [\"a\" \"b\" \"c\"]) \"b\")\n\n\t\n(= (__ [[1 2] [3 4]]) [1 2])```"}]}],"title":"4clojure - Problem 20"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"Bb15FCr1bvU","children":[{"edit-time:":1614171257613,"uid":"Ik2MkaNwACx","string":"**URL:** https://www.4clojure.com/problem/21"},{"edit-time:":1614171257613,"uid":"3_Fvz9jfyTK","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"InZi7Bv4vZ7","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"gtqLA549GP-","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257613,"uid":"GJwi7EHAlIc","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"8EM-WsLkNyD","string":"```clojure\n; Write a function which returns the Nth element from a sequence.\n\n; Special Restrictions:\n; nth\n\n(= (__ '(4 5 6 7) 2) 6)\n\n\t\n(= (__ [:a :b :c] 0) :a)\n\n\t\n(= (__ [1 2 3 4] 1) 2)\n\n\t\n(= (__ '([1 2] [3 4] [5 6]) 2) [5 6])```"}]}],"title":"4clojure - Problem 21"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"PvVQNQHMqje","children":[{"edit-time:":1614171257613,"uid":"zvNTjobPsu2","string":"**URL:** https://www.4clojure.com/problem/22"},{"edit-time:":1614171257613,"uid":"DMI1oA-iaHx","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"c26AdPQJVeF","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"0-8cI15czCz","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257613,"uid":"BYqZl5ZtZno","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"bcTdQarc5RS","string":"```clojure\n; Write a function which returns the total number of elements in a sequence.\n\n; Special Restrictions:\n; count\n\n(= (__ '(1 2 3 3 1)) 5)\n\n\t\n(= (__ \"Hello World\") 11)\n\n\t\n(= (__ [[1 2] [3 4] [5 6]]) 3)\n\n\t\n(= (__ '(13)) 1)\n\n\t\n(= (__ '(:a :b :c)) 3)```"}]}],"title":"4clojure - Problem 22"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"OaE9WxWMn4r","children":[{"edit-time:":1614171257613,"uid":"2GjjT7pUvy0","string":"**URL:** https://www.4clojure.com/problem/23"},{"edit-time:":1614171257613,"uid":"2y9NzMXaTqS","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"FykhONR-Kz1","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"qjnRRSx6o6Y","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257613,"uid":"64XM1jfogBS","string":"**Syntax**:","children":[{"edit-time:":1614171257613,"uid":"uDbEWFm4mHY","string":"```clojure\n(sorted-set ...)```"}]},{"edit-time:":1614171257613,"uid":"xx7eKMspWir","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"X3_tObYKuqf","string":"```clojure\n; Write a function which reverses a sequence.\n\n; Special Restrictions:\n; reverse\n; rseq\n\n(= (__ [1 2 3 4 5]) [5 4 3 2 1])\n\n\t\n(= (__ (sorted-set 5 7 2 7)) '(7 5 2))\n\n\t\n(= (__ [[1 2][3 4][5 6]]) [[5 6][3 4][1 2]])```"}]}],"title":"4clojure - Problem 23"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"mvMuBfR3_4T","children":[{"edit-time:":1614171257613,"uid":"-5AS98qbqi8","string":"**URL:** https://www.4clojure.com/problem/24"},{"edit-time:":1614171257613,"uid":"ppm6w5bQ7Aq","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"qAnAMiAy4Oj","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"XCpux_FrGZw","string":"Topics: seqs"}]},{"edit-time:":1614171257613,"uid":"YqSXq1uYuDQ","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"BXok0bgjBEi","string":"```clojure\n; Write a function which returns the sum of a sequence of numbers.\n\n(= (__ [1 2 3]) 6)\n\n\t\n(= (__ (list 0 -2 5 5)) 8)\n\n\t\n(= (__ #{4 2 1}) 7)\n\n\t\n(= (__ '(0 0 -1)) -1)\n\n\t\n(= (__ '(1 10 3)) 14)```"}]}],"title":"4clojure - Problem 24"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"c8ezwdIzImi","children":[{"edit-time:":1614171257613,"uid":"7_9D0-bfMZP","string":"**URL:** https://www.4clojure.com/problem/25"},{"edit-time:":1614171257613,"uid":"d__Re08vbCO","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"wcjPdEkMcIz","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"satkdeqdcaf","string":"Topics: seqs"}]},{"edit-time:":1614171257613,"uid":"6YPod3cJ7e6","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"yHVm01ln1pi","string":"```clojure\n; Write a function which returns only the odd numbers from a sequence.\n\n(= (__ #{1 2 3 4 5}) '(1 3 5))\n\n\t\n(= (__ [4 2 1 6]) '(1))\n\n\t\n(= (__ [2 2 4 6]) '())\n\n\t\n(= (__ [1 1 1 3]) '(1 1 1 3))```"}]}],"title":"4clojure - Problem 25"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"WBxNvpoJAz1","children":[{"edit-time:":1614171257613,"uid":"0g27zWMQKVH","string":"**URL:** https://www.4clojure.com/problem/26"},{"edit-time:":1614171257613,"uid":"aXUbX1LSfRD","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"SZWISKa7K3a","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"XqPjuNirvkM","string":"Topics: Fibonacci seqs"}]},{"edit-time:":1614171257613,"uid":"q6dLb39HfP6","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"KMpIQtmm2eK","string":"```clojure\n; Write a function which returns the first X fibonacci numbers.\n\n(= (__ 3) '(1 1 2))\n\n\t\n(= (__ 6) '(1 1 2 3 5 8))\n\n\t\n(= (__ 8) '(1 1 2 3 5 8 13 21))```"}]}],"title":"4clojure - Problem 26"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"-n2KiVk8zpA","children":[{"edit-time:":1614171257613,"uid":"PQXChqDk1oM","string":"**URL:** https://www.4clojure.com/problem/27"},{"edit-time:":1614171257613,"uid":"pFwTZtJZJy3","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"J4U4tRPLq_S","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"zyq5lAM3EUR","string":"Topics: seqs"}]},{"edit-time:":1614171257613,"uid":"xW7R3EawHL9","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"H5iS3oJO1_o","string":"```clojure\n; Write a function which returns true if the given sequence is a palindrome.\n; \n; Hint: \"racecar\" does not equal '(\\r \\a \\c \\e \\c \\a \\r)\n\n(false? (__ '(1 2 3 4 5)))\n\n\t\n(true? (__ \"racecar\"))\n\n\t\n(true? (__ [:foo :bar :foo]))\n\n\t\n(true? (__ '(1 1 3 3 1 1)))\n\n\t\n(false? (__ '(:a :b :c)))```"}]}],"title":"4clojure - Problem 27"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"f54SFHJ-Fc4","children":[{"edit-time:":1614171257613,"uid":"nUhXB1W3q9b","string":"**URL:** https://www.4clojure.com/problem/28"},{"edit-time:":1614171257613,"uid":"1tzaRnh-zEj","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"ZgVoYozjvwY","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"_2EgoE4YHx3","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257613,"uid":"rgGfnj7Yfus","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"jwafwu-s56Q","string":"```clojure\n; Write a function which flattens a sequence.\n\n; Special Restrictions:\n; flatten\n\n(= (__ '((1 2) 3 [4 [5 6]])) '(1 2 3 4 5 6))\n\n\t\n(= (__ [\"a\" [\"b\"] \"c\"]) '(\"a\" \"b\" \"c\"))\n\n\t\n(= (__ '((((:a))))) '(:a))```"}]}],"title":"4clojure - Problem 28"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"ZHQCyKLHgs1","children":[{"edit-time:":1614171257613,"uid":"dGWRsPHC7pN","string":"**URL:** https://www.4clojure.com/problem/29"},{"edit-time:":1614171257613,"uid":"l8Ey0qQm3Uh","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"7VR_mDxQbL5","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"gZqdhSTSpnM","string":"Topics: strings"}]},{"edit-time:":1614171257613,"uid":"KCUI7knvgxN","string":"**Syntax**:","children":[{"edit-time:":1614171257613,"uid":"b-SSPsEtJ7U","string":"```clojure\n(empty ...)```"}]},{"edit-time:":1614171257613,"uid":"piwkowq4LLw","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"gyolQpMUMmA","string":"```clojure\n; Write a function which takes a string and returns a new string containing only the capital letters.\n\n(= (__ \"HeLlO, WoRlD!\") \"HLOWRD\")\n\n\t\n(empty? (__ \"nothing\"))\n\n\t\n(= (__ \"$#A(*&987Zf\") \"AZ\")```"}]}],"title":"4clojure - Problem 29"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"C6p-2bNPKTy","children":[{"edit-time:":1614171257613,"uid":"g-FZquQ5LGF","string":"**URL:** https://www.4clojure.com/problem/30"},{"edit-time:":1614171257613,"uid":"xPao9w37RvX","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"eaABSaCGW52","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"3BzGqKPPIVY","string":"Topics: seqs"}]},{"edit-time:":1614171257613,"uid":"Q8ZlZMZB4eu","string":"**Syntax**:","children":[{"edit-time:":1614171257613,"uid":"T7akT109L6e","string":"```clojure\n(apply ...)```"},{"edit-time:":1614171257613,"uid":"QPAbdke4qZC","string":"```clojure\n(str ...)```"}]},{"edit-time:":1614171257613,"uid":"2_NYnM8_cGC","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"UK8WGENzoBR","string":"```clojure\n; Write a function which removes consecutive duplicates from a sequence.\n\n(= (apply str (__ \"Leeeeeerrroyyy\")) \"Leroy\")\n\n\t\n(= (__ [1 1 2 3 3 2 2 3]) '(1 2 3 2 3))\n\n\t\n(= (__ [[1 2] [1 2] [3 4] [1 2]]) '([1 2] [3 4] [1 2]))```"}]}],"title":"4clojure - Problem 30"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"chiIqMUX8dZ","children":[{"edit-time:":1614171257613,"uid":"b9M3v7Kqaq9","string":"**URL:** https://www.4clojure.com/problem/31"},{"edit-time:":1614171257613,"uid":"MpZkOW-EhRC","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"57KbzpG1JNB","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"T0ssb0_cM0g","string":"Topics: seqs"}]},{"edit-time:":1614171257613,"uid":"ly_Ds7rSqVz","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"RBWrxxPHUeg","string":"```clojure\n; Write a function which packs consecutive duplicates into sub-lists.\n\n(= (__ [1 1 2 1 1 1 3 3]) '((1 1) (2) (1 1 1) (3 3)))\n\n\t\n(= (__ [:a :a :b :b :c]) '((:a :a) (:b :b) (:c)))\n\n\t\n(= (__ [[1 2] [1 2] [3 4]]) '(([1 2] [1 2]) ([3 4])))```"}]}],"title":"4clojure - Problem 31"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"9AFuzWxLOjU","children":[{"edit-time:":1614171257613,"uid":"AzZoGO2BBZz","string":"**URL:** https://www.4clojure.com/problem/32"},{"edit-time:":1614171257613,"uid":"P1l09ZjM76-","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"Rgj9W_67KhO","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"IHnuQQ_lHEK","string":"Topics: seqs"}]},{"edit-time:":1614171257613,"uid":"CaxiAU3GEsJ","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"P7EwJJHq-mp","string":"```clojure\n; Write a function which duplicates each element of a sequence.\n\n(= (__ [1 2 3]) '(1 1 2 2 3 3))\n\n\t\n(= (__ [:a :a :b :b]) '(:a :a :a :a :b :b :b :b))\n\n\t\n(= (__ [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))\n\n\t\n(= (__ [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))```"}]}],"title":"4clojure - Problem 32"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"mfNB4OF9BRo","children":[{"edit-time:":1614171257613,"uid":"xyB_1qoqiGf","string":"**URL:** https://www.4clojure.com/problem/33"},{"edit-time:":1614171257613,"uid":"tdiwS2zQT-1","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"rgzC11kiE0E","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"ggAM_xYUi9N","string":"Topics: seqs"}]},{"edit-time:":1614171257613,"uid":"Sy078tV11TY","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"P_5LHep1298","string":"```clojure\n; Write a function which replicates each element of a sequence a variable number of times.\n\n(= (__ [1 2 3] 2) '(1 1 2 2 3 3))\n\n\t\n(= (__ [:a :b] 4) '(:a :a :a :a :b :b :b :b))\n\n\t\n(= (__ [4 5 6] 1) '(4 5 6))\n\n\t\n(= (__ [[1 2] [3 4]] 2) '([1 2] [1 2] [3 4] [3 4]))\n\n\t\n(= (__ [44 33] 2) [44 44 33 33])```"}]}],"title":"4clojure - Problem 33"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"EqMPi7GR-6i","children":[{"edit-time:":1614171257613,"uid":"pNASrvqiEyK","string":"**URL:** https://www.4clojure.com/problem/34"},{"edit-time:":1614171257613,"uid":"mE4UoFY8W3u","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"nevH1CO8Er2","string":"Difficulty: Easy"},{"edit-time:":1614171257613,"uid":"eN5ioDnnBAD","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257613,"uid":"clqZVwE27m1","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"K3OA_uTBkhR","string":"```clojure\n; Write a function which creates a list of all integers in a given range.\n\n; Special Restrictions:\n; range\n\n(= (__ 1 4) '(1 2 3))\n\n\t\n(= (__ -2 2) '(-2 -1 0 1))\n\n\t\n(= (__ 5 8) '(5 6 7))```"}]}],"title":"4clojure - Problem 34"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"U_ycxbwfZiw","children":[{"edit-time:":1614171257613,"uid":"-7HTiymyvoU","string":"**URL:** https://www.4clojure.com/problem/35"},{"edit-time:":1614171257613,"uid":"Cd6we5DjvkH","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"Lzyo4XYZ_Ax","string":"Difficulty: Elementary"},{"edit-time:":1614171257613,"uid":"xWt5IN3WE-I","string":"Topics: syntax"}]},{"edit-time:":1614171257613,"uid":"3H7USQi5sBS","string":"**Syntax**:","children":[{"edit-time:":1614171257613,"uid":"egfJUG_PaXs","string":"```clojure\n(/ ...)```"}]},{"edit-time:":1614171257613,"uid":"jCXo84jFHa8","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"tvT2g656um2","string":"```clojure\n; Clojure lets you give local names to values using the special let-form.\n\n(= __ (let [x 5] (+ 2 x)))\n\n\t\n(= __ (let [x 3, y 10] (- y x)))\n\n\t\n(= __ (let [x 21] (let [y 3] (/ x y))))```"}]}],"title":"4clojure - Problem 35"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"4OgoolpRkdo","children":[{"edit-time:":1614171257613,"uid":"KcFZKIlXDuO","string":"**URL:** https://www.4clojure.com/problem/36"},{"edit-time:":1614171257613,"uid":"xHzfyqAiKrn","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"Qz9X_44-hUF","string":"Difficulty: Elementary"},{"edit-time:":1614171257613,"uid":"y6gSGppAbuK","string":"Topics: math syntax"}]},{"edit-time:":1614171257613,"uid":"gblCuKZyt_p","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"26VeEdqW6zS","string":"```clojure\n; Can you bind x, y, and z so that these are all true?\n\n(= 10 (let __ (+ x y)))\n\n\t\n(= 4 (let __ (+ y z)))\n\n\t\n(= 1 (let __ z))```"}]}],"title":"4clojure - Problem 36"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"vCdnIzoyozm","children":[{"edit-time:":1614171257613,"uid":"Rn6ugw6OuBx","string":"**URL:** https://www.4clojure.com/problem/37"},{"edit-time:":1614171257613,"uid":"EQqvAUun_oj","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257613,"uid":"L-6argQSQE9","string":"Difficulty: Elementary"},{"edit-time:":1614171257613,"uid":"uJ6aBEmhPmd","string":"Topics: regex syntax"}]},{"edit-time:":1614171257613,"uid":"aQE_hYo0DHR","string":"**Syntax**:","children":[{"edit-time:":1614171257613,"uid":"jsqMhL4ZoLX","string":"```clojure\n(re-seq ...)```"}]},{"edit-time:":1614171257613,"uid":"GExJHHVcrdH","string":"**Problem:**","children":[{"edit-time:":1614171257613,"uid":"uVFpwtYV35K","string":"```clojure\n; Regex patterns are supported with a special reader macro.\n\n(= __ (apply str (re-seq #\"[A-Z]+\" \"bA1B3Ce \")))```"}]}],"title":"4clojure - Problem 37"},{"create-time":1614171257613,"edit-time:":1614171257613,"uid":"w04-gJxtGTB","children":[{"edit-time:":1614171257614,"uid":"Hl1iWymdLlk","string":"**URL:** https://www.4clojure.com/problem/38"},{"edit-time:":1614171257614,"uid":"UExCnCitorL","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"fFuA6nNa4sv","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"JhAxWPrecF2","string":"Topics: core-functions"}]},{"edit-time:":1614171257614,"uid":"0QeBQjPhUFJ","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"_4KtuZKO91e","string":"```clojure\n; Write a function which takes a variable number of parameters and returns the maximum value.\n\n; Special Restrictions:\n; max\n; max-key\n\n(= (__ 1 8 3 4) 8)\n\n\t\n(= (__ 30 20) 30)\n\n\t\n(= (__ 45 67 11) 67)```"}]}],"title":"4clojure - Problem 38"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"ajCXQxu-EyA","children":[{"edit-time:":1614171257614,"uid":"xHMFJKybExQ","string":"**URL:** https://www.4clojure.com/problem/39"},{"edit-time:":1614171257614,"uid":"MuSJ2EGrYqv","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"nkglvv0sAS5","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"ZvbpTHV7l8f","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257614,"uid":"b-T0_EBWYyf","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"UJhXh2rWcAE","string":"```clojure\n; Write a function which takes two sequences and returns the first item from each, then the second item from each, then the third, etc.\n\n; Special Restrictions:\n; interleave\n\n(= (__ [1 2 3] [:a :b :c]) '(1 :a 2 :b 3 :c))\n\n\t\n(= (__ [1 2] [3 4 5 6]) '(1 3 2 4))\n\n\t\n(= (__ [1 2 3 4] [5]) [1 5])\n\n\t\n(= (__ [30 20] [25 15]) [30 25 20 15])```"}]}],"title":"4clojure - Problem 39"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"EPJBYk9Sm7L","children":[{"edit-time:":1614171257614,"uid":"jwIVRhWsAB1","string":"**URL:** https://www.4clojure.com/problem/40"},{"edit-time:":1614171257614,"uid":"nppVjkx5jT2","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"oZN0ZX5RPtr","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"9plNl7XNoWm","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257614,"uid":"LjvpLQ4afBr","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"akxS5BRX0AU","string":"```clojure\n; Write a function which separates the items of a sequence by an arbitrary value.\n\n; Special Restrictions:\n; interpose\n\n(= (__ 0 [1 2 3]) [1 0 2 0 3])\n\n\t\n(= (apply str (__ \", \" [\"one\" \"two\" \"three\"])) \"one, two, three\")\n\n\t\n(= (__ :z [:a :b :c :d]) [:a :z :b :z :c :z :d])```"}]}],"title":"4clojure - Problem 40"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"jQhKv9AJsFj","children":[{"edit-time:":1614171257614,"uid":"nWyVQfDe7Kp","string":"**URL:** https://www.4clojure.com/problem/41"},{"edit-time:":1614171257614,"uid":"oNJyTLyNrwh","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"m2kHsV-R6LJ","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"x7PGN4MYf4i","string":"Topics: seqs"}]},{"edit-time:":1614171257614,"uid":"RkDunmRLG3H","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"vvtZm8Q4-y7","string":"```clojure\n; Write a function which drops every Nth item from a sequence.\n\n(= (__ [1 2 3 4 5 6 7 8] 3) [1 2 4 5 7 8])\n\n\t\n(= (__ [:a :b :c :d :e :f] 2) [:a :c :e])\n\n\t\n(= (__ [1 2 3 4 5 6] 4) [1 2 3 5 6])```"}]}],"title":"4clojure - Problem 41"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"rUYd-YCDbz4","children":[{"edit-time:":1614171257614,"uid":"wkinr95Xqap","string":"**URL:** https://www.4clojure.com/problem/42"},{"edit-time:":1614171257614,"uid":"fvJWFTp_IYi","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"748pbxI2Nm6","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"FtVO9juN1es","string":"Topics: math"}]},{"edit-time:":1614171257614,"uid":"UhwmFgnmVii","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"C2BRclE7Ab3","string":"```clojure\n; Write a function which calculates factorials.\n\n(= (__ 1) 1)\n\n\t\n(= (__ 3) 6)\n\n\t\n(= (__ 5) 120)\n\n\t\n(= (__ 8) 40320)```"}]}],"title":"4clojure - Problem 42"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"BmgrtxcCdIv","children":[{"edit-time:":1614171257614,"uid":"bPsr1_2_WCq","string":"**URL:** https://www.4clojure.com/problem/43"},{"edit-time:":1614171257614,"uid":"MQEbBMievaE","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"__RS9N5hSGM","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"jBAZUz7zYST","string":"Topics: seqs"}]},{"edit-time:":1614171257614,"uid":"Rt5J-9EUn-7","string":"**Syntax**:","children":[{"edit-time:":1614171257614,"uid":"9b8tK28Pzjd","string":"```clojure\n(range ...)```"}]},{"edit-time:":1614171257614,"uid":"KEmrPuboEkP","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"9GDcTiveYiW","string":"```clojure\n; Write a function which reverses the interleave process into x number of subsequences.\n\n(= (__ [1 2 3 4 5 6] 2) '((1 3 5) (2 4 6)))\n\n\t\n(= (__ (range 9) 3) '((0 3 6) (1 4 7) (2 5 8)))\n\n\t\n(= (__ (range 10) 5) '((0 5) (1 6) (2 7) (3 8) (4 9)))```"}]}],"title":"4clojure - Problem 43"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"kLXLztUfp1f","children":[{"edit-time:":1614171257614,"uid":"w8mwqtXm3cf","string":"**URL:** https://www.4clojure.com/problem/44"},{"edit-time:":1614171257614,"uid":"ESc7GTI3pvj","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"0LGnwEFzmYg","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"Bse3EIqWNf-","string":"Topics: seqs"}]},{"edit-time:":1614171257614,"uid":"2yHWZi6CNFZ","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"ZXL8VNx0RTZ","string":"```clojure\n; Write a function which can rotate a sequence in either direction.\n\n(= (__ 2 [1 2 3 4 5]) '(3 4 5 1 2))\n\n\t\n(= (__ -2 [1 2 3 4 5]) '(4 5 1 2 3))\n\n\t\n(= (__ 6 [1 2 3 4 5]) '(2 3 4 5 1))\n\n\t\n(= (__ 1 '(:a :b :c)) '(:b :c :a))\n\n\t\n(= (__ -4 '(:a :b :c)) '(:c :a :b))```"}]}],"title":"4clojure - Problem 44"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"sBA6_921r9p","children":[{"edit-time:":1614171257614,"uid":"dY9GNfaTMRY","string":"**URL:** https://www.4clojure.com/problem/45"},{"edit-time:":1614171257614,"uid":"G--i8GQ5M6e","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"_ujqL5wtOGe","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"0pBlF6Slcco","string":"Topics: seqs"}]},{"edit-time:":1614171257614,"uid":"BfW5l4W6god","string":"**Syntax**:","children":[{"edit-time:":1614171257614,"uid":"EmQyzwwWv_u","string":"```clojure\n(take ...)```"},{"edit-time:":1614171257614,"uid":"gM2e5Bzrm1f","string":"```clojure\n(iterate ...)```"}]},{"edit-time:":1614171257614,"uid":"dfHwPaUCQrr","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"vh2XvFSOlp4","string":"```clojure\n; The iterate function can be used to produce an infinite lazy sequence.\n\n(= __ (take 5 (iterate #(+ 3 %) 1)))```"}]}],"title":"4clojure - Problem 45"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"N68NZHXPruM","children":[{"edit-time:":1614171257614,"uid":"uFgKm-7tXSN","string":"**URL:** https://www.4clojure.com/problem/46"},{"edit-time:":1614171257614,"uid":"lZTGCT2EvNY","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"7vQkuEHaxD4","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"_e-uguQegg-","string":"Topics: higher-order-functions"}]},{"edit-time:":1614171257614,"uid":"VcxC4bm8qmi","string":"**Syntax**:","children":[{"edit-time:":1614171257614,"uid":"6ukHO9rBZ0T","string":"```clojure\n(nth ...)```"},{"edit-time:":1614171257614,"uid":"uBN1EevFDDR","string":"```clojure\n(quot ...)```"}]},{"edit-time:":1614171257614,"uid":"Wb8dhZOJGIe","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"FxUg2ntomqN","string":"```clojure\n; Write a higher-order function which flips the order of the arguments of an input function.\n\n(= 3 ((__ nth) 2 [1 2 3 4 5]))\n\n\t\n(= true ((__ >) 7 8))\n\n\t\n(= 4 ((__ quot) 2 8))\n\n\t\n(= [1 2 3] ((__ take) [1 2 3 4 5] 3))```"}]}],"title":"4clojure - Problem 46"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"NEkBC_t3rfS","children":[{"edit-time:":1614171257614,"uid":"dixbws_6Ips","string":"**URL:** https://www.4clojure.com/problem/47"},{"edit-time:":1614171257614,"uid":"OGnCKfeZfit","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"_0j0LAAegTQ","string":"Difficulty: Easy"}]},{"edit-time:":1614171257614,"uid":"YtYrqH6oUaR","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"msRfAqO-2pO","string":"```clojure\n; The contains? function checks if a KEY is present in a given collection.\n; This often leads beginner clojurians to use it incorrectly with numerically indexed collections like vectors and lists.\n\n(contains? #{4 5 6} __)\n\n\t\n(contains? [1 1 1 1 1] __)\n\n\t\n(contains? {4 :a 2 :b} __)\n\n\t\n(not (contains? [1 2 4] __))```"}]}],"title":"4clojure - Problem 47"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"X6n80FKUZ3S","children":[{"edit-time:":1614171257614,"uid":"MTgduQuCcDN","string":"**URL:** https://www.4clojure.com/problem/48"},{"edit-time:":1614171257614,"uid":"H0n0lTV0mMj","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"P1LuiVgyFTZ","string":"Difficulty: Easy"}]},{"edit-time:":1614171257614,"uid":"Wz1h-lEUei2","string":"**Syntax**:","children":[{"edit-time:":1614171257614,"uid":"EIfG-EZUYdu","string":"```clojure\n(some ...)```"}]},{"edit-time:":1614171257614,"uid":"GABVQkNOVE5","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"L_tCizhxGe9","string":"```clojure\n; The some function takes a predicate function and a collection.\n; It returns the first logical true value of (predicate x) where x is an item in the collection.\n\n(= __ (some #{2 7 6} [5 6 7 8]))\n\n\t\n(= __ (some #(when (even? %) %) [5 6 7 8]))```"}]}],"title":"4clojure - Problem 48"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"uNEUR4E__gu","children":[{"edit-time:":1614171257614,"uid":"IK-KxPSD6p-","string":"**URL:** https://www.4clojure.com/problem/49"},{"edit-time:":1614171257614,"uid":"GiUZrpNHBPL","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"MUjZyT8uQ43","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"YXHtY5-kYBn","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257614,"uid":"raQhn7pkzZs","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"WsYm0zPXCFB","string":"```clojure\n; Write a function which will split a sequence into two parts.\n\n; Special Restrictions:\n; split-at\n\n(= (__ 3 [1 2 3 4 5 6]) [[1 2 3] [4 5 6]])\n\n\t\n(= (__ 1 [:a :b :c :d]) [[:a] [:b :c :d]])\n\n\t\n(= (__ 2 [[1 2] [3 4] [5 6]]) [[[1 2] [3 4]] [[5 6]]])```"}]}],"title":"4clojure - Problem 49"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"DnMagvA3zs3","children":[{"edit-time:":1614171257614,"uid":"zYiXygreUrk","string":"**URL:** https://www.4clojure.com/problem/50"},{"edit-time:":1614171257614,"uid":"kx1SFPGRfgk","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"bGXy1b4zlXs","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"2Rej3X57wgG","string":"Topics: seqs"}]},{"edit-time:":1614171257614,"uid":"IRMsby8IGjA","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"__0Fd28u-W7","string":"```clojure\n; Write a function which takes a sequence consisting of items with different types and splits them up into a set of homogeneous sub-sequences.\n; The internal order of each sub-sequence should be maintained, but the sub-sequences themselves can be returned in any order (this is why 'set' is used in the test cases).\n\n(= (set (__ [1 :a 2 :b 3 :c])) #{[1 2 3] [:a :b :c]})\n\n\t\n(= (set (__ [:a \"foo\"  \"bar\" :b])) #{[:a :b] [\"foo\" \"bar\"]})\n\n\t\n(= (set (__ [[1 2] :a [3 4] 5 6 :b])) #{[[1 2] [3 4]] [:a :b] [5 6]})```"}]}],"title":"4clojure - Problem 50"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"M0d6qM1IjTE","children":[{"edit-time:":1614171257614,"uid":"ZF20qmG88vb","string":"**URL:** https://www.4clojure.com/problem/51"},{"edit-time:":1614171257614,"uid":"L12eo85W8QZ","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"w3rZ1XwUUIP","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"zsbOWx2AAKx","string":"Topics: destructuring"}]},{"edit-time:":1614171257614,"uid":"d4AF_3fA8pD","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"E6DUznl0oE2","string":"```clojure\n; Here is an example of some more sophisticated destructuring.\n\n(= [1 2 [3 4 5] [1 2 3 4 5]] (let [[a b & c :as d] __] [a b c d]))```"}]}],"title":"4clojure - Problem 51"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"e4y5d9Gu1Wu","children":[{"edit-time:":1614171257614,"uid":"yJAXkbo3qzu","string":"**URL:** https://www.4clojure.com/problem/52"},{"edit-time:":1614171257614,"uid":"fEu_VjypEmM","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"Stv3Cm-s0Rv","string":"Difficulty: Elementary"},{"edit-time:":1614171257614,"uid":"TwDo1myZbgk","string":"Topics: destructuring"}]},{"edit-time:":1614171257614,"uid":"gfZOZLU5BtG","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"HzA0LXU-bJN","string":"```clojure\n; Let bindings and function parameter lists support destructuring.\n\n(= [2 4] (let [[a b c d e] [0 1 2 3 4]] __))```"}]}],"title":"4clojure - Problem 52"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"shmztTi7J24","children":[{"edit-time:":1614171257614,"uid":"96v1GRZ94sQ","string":"**URL:** https://www.4clojure.com/problem/53"},{"edit-time:":1614171257614,"uid":"tbg-WeK-MLf","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"vEifZhRcu3A","string":"Difficulty: Hard"},{"edit-time:":1614171257614,"uid":"oGa_VVNiKFW","string":"Topics: seqs"}]},{"edit-time:":1614171257614,"uid":"5FQMtpB_3nb","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"QUMsUE53PE8","string":"```clojure\n; Given a vector of integers, find the longest consecutive sub-sequence of increasing numbers.\n; If two sub-sequences have the same length, use the one that occurs first.\n; An increasing sub-sequence must have a length of 2 or greater to qualify.\n\n(= (__ [1 0 1 2 3 0 4 5]) [0 1 2 3])\n\n\t\n(= (__ [5 6 1 3 2 7]) [5 6])\n\n\t\n(= (__ [2 3 3 4 5]) [3 4 5])\n\n\t\n(= (__ [7 6 5 4]) [])```"}]}],"title":"4clojure - Problem 53"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"t-IpIhakjEF","children":[{"edit-time:":1614171257614,"uid":"TzMcbElWCeF","string":"**URL:** https://www.4clojure.com/problem/54"},{"edit-time:":1614171257614,"uid":"a76BxNdzHQQ","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"QqmjdJ4B_ku","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"YeSswMQyLkD","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257614,"uid":"lWZLd2nK5bO","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"XzSEKYJo45k","string":"```clojure\n; Write a function which returns a sequence of lists of x items each.\n; Lists of less than x items should not be returned.\n\n; Special Restrictions:\n; partition\n; partition-all\n\n(= (__ 3 (range 9)) '((0 1 2) (3 4 5) (6 7 8)))\n\n\t\n(= (__ 2 (range 8)) '((0 1) (2 3) (4 5) (6 7)))\n\n\t\n(= (__ 3 (range 8)) '((0 1 2) (3 4 5)))```"}]}],"title":"4clojure - Problem 54"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"LD1vAHnzV5B","children":[{"edit-time:":1614171257614,"uid":"DWc8LTVW9CB","string":"**URL:** https://www.4clojure.com/problem/55"},{"edit-time:":1614171257614,"uid":"CBhoGbGb4PJ","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"SMkS9Dsz-Em","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"UqEWP_a1YdN","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257614,"uid":"zgDa6Ur1dXK","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"OhjqQX_QRcy","string":"```clojure\n; Write a function which returns a map containing the number of occurences of each distinct item in a sequence.\n\n; Special Restrictions:\n; frequencies\n\n(= (__ [1 1 2 3 2 1 1]) {1 4, 2 2, 3 1})\n\n\t\n(= (__ [:b :a :b :a :b]) {:a 2, :b 3})\n\n\t\n(= (__ '([1 2] [1 3] [1 3])) {[1 2] 1, [1 3] 2})```"}]}],"title":"4clojure - Problem 55"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"Agrmb-D0slj","children":[{"edit-time:":1614171257614,"uid":"R-2XJuTpo22","string":"**URL:** https://www.4clojure.com/problem/56"},{"edit-time:":1614171257614,"uid":"YNKxN_k1JHb","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"JiKZ1sWns6p","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"BChhaA5SzCd","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257614,"uid":"7Zs-hCMYm-f","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"ELJSs_Y0dza","string":"```clojure\n; Write a function which removes the duplicates from a sequence.\n; Order of the items must be maintained.\n\n; Special Restrictions:\n; distinct\n\n(= (__ [1 2 1 3 1 2 4]) [1 2 3 4])\n\n\t\n(= (__ [:a :a :b :b :c :c]) [:a :b :c])\n\n\t\n(= (__ '([2 4] [1 2] [1 3] [1 3])) '([2 4] [1 2] [1 3]))\n\n\t\n(= (__ (range 50)) (range 50))```"}]}],"title":"4clojure - Problem 56"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"vufjzeuMX8s","children":[{"edit-time:":1614171257614,"uid":"mJI6PABp1qk","string":"**URL:** https://www.4clojure.com/problem/57"},{"edit-time:":1614171257614,"uid":"WjBvLRpibae","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"4BqvCq1mluO","string":"Difficulty: Elementary"},{"edit-time:":1614171257614,"uid":"HqXPqmNcISv","string":"Topics: recursion"}]},{"edit-time:":1614171257614,"uid":"XP0NJEYYi60","string":"**Syntax**:","children":[{"edit-time:":1614171257614,"uid":"_6uhZtTHlj-","string":"```clojure\n(dec ...)```"}]},{"edit-time:":1614171257614,"uid":"PR-w0JzvKTU","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"v4GusuzMNO1","string":"```clojure\n; A recursive function is a function which calls itself.\n; This is one of the fundamental techniques used in functional programming.\n\n(= __ ((fn foo [x] (when (> x 0) (conj (foo (dec x)) x))) 5))```"}]}],"title":"4clojure - Problem 57"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"HJdYIiWdNoQ","children":[{"edit-time:":1614171257614,"uid":"CxzYuiNq69h","string":"**URL:** https://www.4clojure.com/problem/58"},{"edit-time:":1614171257614,"uid":"iDgLgBrEfkM","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"M46e3QQrf_G","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"lZg6bXItEIi","string":"Topics: higher-order-functions core-functions"}]},{"edit-time:":1614171257614,"uid":"eDtfaE6X_it","string":"**Syntax**:","children":[{"edit-time:":1614171257614,"uid":"2Kxdwq1ij2a","string":"```clojure\n(reverse ...)```"},{"edit-time:":1614171257614,"uid":"fswPUKq405w","string":"```clojure\n(mod ...)```"}]},{"edit-time:":1614171257614,"uid":"GrmCIk-dpl5","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"0efNC392Rcy","string":"```clojure\n; Write a function which allows you to create function compositions.\n; The parameter list should take a variable number of functions, and create a function that applies them from right-to-left.\n\n; Special Restrictions:\n; comp\n\n(= [3 2 1] ((__ rest reverse) [1 2 3 4]))\n\n\t\n(= 5 ((__ (partial + 3) second) [1 2 3 4]))\n\n\t\n(= true ((__ zero? #(mod % 8) +) 3 5 7 9))\n\n\t\n(= \"HELLO\" ((__ #(.toUpperCase %) #(apply str %) take) 5 \"hello world\"))```"}]}],"title":"4clojure - Problem 58"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"0e3kXQu5I5d","children":[{"edit-time:":1614171257614,"uid":"CendixlyA-8","string":"**URL:** https://www.4clojure.com/problem/59"},{"edit-time:":1614171257614,"uid":"w355086XGvs","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"p7RRiZoD5Lp","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"sB5eEpp3VXP","string":"Topics: higher-order-functions core-functions"}]},{"edit-time:":1614171257614,"uid":"7oOzFImNml_","string":"**Syntax**:","children":[{"edit-time:":1614171257614,"uid":"TicQLcGoiMs","string":"```clojure\n(min ...)```"},{"edit-time:":1614171257614,"uid":"aiC9Wt6kUBm","string":"```clojure\n(count ...)```"}]},{"edit-time:":1614171257614,"uid":"VVwc0z6hAbu","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"slSiHPbq9Vr","string":"```clojure\n; Take a set of functions and return a new function that takes a variable number of arguments and returns a sequence containing the result of applying each function left-to-right to the argument list.\n\n; Special Restrictions:\n; juxt\n\n(= [21 6 1] ((__ + max min) 2 3 5 1 6 4))\n\n\t\n(= [\"HELLO\" 5] ((__ #(.toUpperCase %) count) \"hello\"))\n\n\t\n(= [2 6 4] ((__ :a :c :b) {:a 2, :b 4, :c 6, :d 8 :e 10}))```"}]}],"title":"4clojure - Problem 59"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"hxrAGXGQ9bY","children":[{"edit-time:":1614171257614,"uid":"d1kUS_yn4S1","string":"**URL:** https://www.4clojure.com/problem/60"},{"edit-time:":1614171257614,"uid":"ArjbGuO9vOM","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"e3e0RN7MW5I","string":"Difficulty: Medium"},{"edit-time:":1614171257614,"uid":"oQF3gyc9sxJ","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257614,"uid":"lcweSkwQ26v","string":"**Syntax**:","children":[{"edit-time:":1614171257614,"uid":"qcvjxliofF1","string":"```clojure\n(reduce ...)```"}]},{"edit-time:":1614171257614,"uid":"cvvcFpuWqxk","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"9OdPpsomEM_","string":"```clojure\n; Write a function which behaves like reduce, but returns each intermediate value of the reduction.\n; Your function must accept either two or three arguments, and the return sequence must be lazy.\n\n; Special Restrictions:\n; reductions\n\n(= (take 5 (__ + (range))) [0 1 3 6 10])\n\n\t\n(= (__ conj [1] [2 3 4]) [[1] [1 2] [1 2 3] [1 2 3 4]])\n\n\t\n(= (last (__ * 2 [3 4 5])) (reduce * 2 [3 4 5]) 120)```"}]}],"title":"4clojure - Problem 60"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"egcTGr4hbS_","children":[{"edit-time:":1614171257614,"uid":"hvSZa0OwKIx","string":"**URL:** https://www.4clojure.com/problem/61"},{"edit-time:":1614171257614,"uid":"tNCPsHYCFpg","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"IKnO04DPyUN","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"sjY-_Yh50fl","string":"Topics: core-functions"}]},{"edit-time:":1614171257614,"uid":"8A7MZjm8oOj","string":"**Problem:**","children":[{"edit-time:":1614171257614,"uid":"-QhTNz4N3l1","string":"```clojure\n; Write a function which takes a vector of keys and a vector of values and constructs a map from them.\n\n; Special Restrictions:\n; zipmap\n\n(= (__ [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3})\n\n\t\n(= (__ [1 2 3 4] [\"one\" \"two\" \"three\"]) {1 \"one\", 2 \"two\", 3 \"three\"})\n\n\t\n(= (__ [:foo :bar] [\"foo\" \"bar\" \"baz\"]) {:foo \"foo\", :bar \"bar\"})```"}]}],"title":"4clojure - Problem 61"},{"create-time":1614171257614,"edit-time:":1614171257614,"uid":"wgqIT_8fCyt","children":[{"edit-time:":1614171257614,"uid":"Djldag6rEtt","string":"**URL:** https://www.4clojure.com/problem/62"},{"edit-time:":1614171257614,"uid":"dubStKov39X","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257614,"uid":"kDTrT-Tftzg","string":"Difficulty: Easy"},{"edit-time:":1614171257614,"uid":"AHDVJDXYx9e","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257614,"uid":"UvFZWirm-nh","string":"**Syntax**:","children":[{"edit-time:":1614171257615,"uid":"7tHPbv2Gt8k","string":"```clojure\n(inc ...)```"},{"edit-time:":1614171257615,"uid":"_Ll0HE2WiAq","string":"```clojure\n(cycle ...)```"}]},{"edit-time:":1614171257615,"uid":"nVjAI1JRJkF","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"JjQyzKmHTaZ","string":"```clojure\n; Given a side-effect free function f and an initial value x write a function which returns an infinite lazy sequence of x, (f x), (f (f x)), (f (f (f x))), etc.\n\n; Special Restrictions:\n; iterate\n\n(= (take 5 (__ #(* 2 %) 1)) [1 2 4 8 16])\n\n\t\n(= (take 100 (__ inc 0)) (take 100 (range)))\n\n\t\n(= (take 9 (__ #(inc (mod % 3)) 1)) (take 9 (cycle [1 2 3])))```"}]}],"title":"4clojure - Problem 62"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"9vgokGr-1ke","children":[{"edit-time:":1614171257615,"uid":"bq9WvZ2kaTQ","string":"**URL:** https://www.4clojure.com/problem/63"},{"edit-time:":1614171257615,"uid":"WDtAISKXlw_","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"TgGNqQ7X-vt","string":"Difficulty: Easy"},{"edit-time:":1614171257615,"uid":"-kFRYgz99N7","string":"Topics: core-functions"}]},{"edit-time:":1614171257615,"uid":"6UOHfK82aPZ","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"1R1DUsYSw-d","string":"```clojure\n; Given a function f and a sequence s, write a function which returns a map.\n; The keys should be the values of f applied to each item in s.\n; The value at each key should be a vector of corresponding items in the order they appear in s.\n\n; Special Restrictions:\n; group-by\n\n(= (__ #(> % 5) [1 3 6 8]) {false [1 3], true [6 8]})\n\n\t\n(= (__ #(apply / %) [[1 2] [2 4] [4 6] [3 6]])\n   {1/2 [[1 2] [2 4] [3 6]], 2/3 [[4 6]]})\n\n\t\n(= (__ count [[1] [1 2] [3] [1 2 3] [2 3]])\n   {1 [[1] [3]], 2 [[1 2] [2 3]], 3 [[1 2 3]]})```"}]}],"title":"4clojure - Problem 63"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"muBdQwC98Ie","children":[{"edit-time:":1614171257615,"uid":"xMVpjK9ygQC","string":"**URL:** https://www.4clojure.com/problem/64"},{"edit-time:":1614171257615,"uid":"OV4v-ppgcLp","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"Cp9VKj2PMyj","string":"Difficulty: Elementary"},{"edit-time:":1614171257615,"uid":"1wYvqxrCIvb","string":"Topics: seqs"}]},{"edit-time:":1614171257615,"uid":"6OsUiJalCt0","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"ru3gDZeOKCq","string":"```clojure\n; Reduce takes a 2 argument function and an optional starting value.\n; It then applies the function to the first 2 items in the sequence (or the starting value and the first element of the sequence).\n; In the next iteration the function will be called on the previous return value and the next item from the sequence, thus reducing the entire collection to one value.\n; Don't worry, it's not as complicated as it sounds.\n\n(= 15 (reduce __ [1 2 3 4 5]))\n\n\t\n(=  0 (reduce __ []))\n\n\t\n(=  6 (reduce __ 1 [2 3]))```"}]}],"title":"4clojure - Problem 64"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"pxDeGTKWQQe","children":[{"edit-time:":1614171257615,"uid":"P3KjKYPcTd_","string":"**URL:** https://www.4clojure.com/problem/65"},{"edit-time:":1614171257615,"uid":"uN_ON5rY7Hr","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"Mk8V3Eh5lkw","string":"Difficulty: Medium"},{"edit-time:":1614171257615,"uid":"E7C92dxsx89","string":"Topics: seqs testing"}]},{"edit-time:":1614171257615,"uid":"J-E2ycgdmlK","string":"**Syntax**:","children":[{"edit-time:":1614171257615,"uid":"S9Ro2iKo-8e","string":"```clojure\n(rand-int ...)```"}]},{"edit-time:":1614171257615,"uid":"Vt0mEnEy7YD","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"DXLVOUhL_wF","string":"```clojure\n; Clojure has many sequence types, which act in subtly different ways.\n; The core functions typically convert them into a uniform \"sequence\" type and work with them that way, but it can be important to understand the behavioral and performance differences so that you know which kind is appropriate for your application.\n; \n; \n; Write a function which takes a collection and returns one of :map, :set, :list, or :vector - describing the type of collection it was given.\n; You won't be allowed to inspect their class or use the built-in predicates like list? - the point is to poke at them and understand their behavior.\n\n; Special Restrictions:\n; class\n; type\n; Class\n; vector?\n; sequential?\n; list?\n; seq?\n; map?\n; set?\n; instance?\n; getClass\n\n(= :map (__ {:a 1, :b 2}))\n\n\t\n(= :list (__ (range (rand-int 20))))\n\n\t\n(= :vector (__ [1 2 3 4 5 6]))\n\n\t\n(= :set (__ #{10 (rand-int 5)}))\n\n\t\n(= [:map :set :vector :list] (map __ [{} #{} [] ()]))```"}]}],"title":"4clojure - Problem 65"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"QGU3ZUEUaAo","children":[{"edit-time:":1614171257615,"uid":"Q7I_Cl7Uc5q","string":"**URL:** https://www.4clojure.com/problem/66"},{"edit-time:":1614171257615,"uid":"1CSLHJNRS45","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"Yi3OAExsOu4","string":"Difficulty: Easy"}]},{"edit-time:":1614171257615,"uid":"0arCs1j6aLG","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"W8C8bwUMFjR","string":"```clojure\n; Given two integers, write a function which returns the greatest common divisor.\n\n(= (__ 2 4) 2)\n\n\t\n(= (__ 10 5) 5)\n\n\t\n(= (__ 5 7) 1)\n\n\t\n(= (__ 1023 858) 33)```"}]}],"title":"4clojure - Problem 66"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"wH_9YOTYHLl","children":[{"edit-time:":1614171257615,"uid":"FJLPIscBcaj","string":"**URL:** https://www.4clojure.com/problem/67"},{"edit-time:":1614171257615,"uid":"IZPyYhuR1OQ","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"1je0S0C1sLW","string":"Difficulty: Medium"},{"edit-time:":1614171257615,"uid":"Gha3559ZYNj","string":"Topics: primes"}]},{"edit-time:":1614171257615,"uid":"bT7ZBNrYImt","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"mko9dOwjGxS","string":"```clojure\n; Write a function which returns the first x number of prime numbers.\n\n(= (__ 2) [2 3])\n\n\t\n(= (__ 5) [2 3 5 7 11])\n\n\t\n(= (last (__ 100)) 541)```"}]}],"title":"4clojure - Problem 67"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"YAqXLCsbjSC","children":[{"edit-time:":1614171257615,"uid":"40XNyfHuisL","string":"**URL:** https://www.4clojure.com/problem/68"},{"edit-time:":1614171257615,"uid":"Pgr3BYAooUH","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"hBOXCZJZMiQ","string":"Difficulty: Elementary"},{"edit-time:":1614171257615,"uid":"7d3wUKNfREw","string":"Topics: recursion"}]},{"edit-time:":1614171257615,"uid":"L25yH_-PPCz","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"ozkedUr9CCR","string":"```clojure\n; Clojure only has one non-stack-consuming looping construct: recur.\n; Either a function or a loop can be used as the recursion point.\n; Either way, recur rebinds the bindings of the recursion point to the values it is passed.\n; Recur must be called from the tail-position, and calling it elsewhere will result in an error.\n\n(= __\n  (loop [x 5\n         result []]\n    (if (> x 0)\n      (recur (dec x) (conj result (+ 2 x)))\n      result)))```"}]}],"title":"4clojure - Problem 68"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"Ca475aNUuv_","children":[{"edit-time:":1614171257615,"uid":"Z7zdga6CLOr","string":"**URL:** https://www.4clojure.com/problem/69"},{"edit-time:":1614171257615,"uid":"CwrCS_67YOl","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"GL6rNWHkG2l","string":"Difficulty: Medium"},{"edit-time:":1614171257615,"uid":"XSJ_YrS4Imd","string":"Topics: core-functions"}]},{"edit-time:":1614171257615,"uid":"iptEx-lewxZ","string":"**Syntax**:","children":[{"edit-time:":1614171257615,"uid":"1m5FtUZbw0y","string":"```clojure\n(concat ...)```"}]},{"edit-time:":1614171257615,"uid":"-3cV6Cf9FI-","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"aa8TII_wYIb","string":"```clojure\n; Write a function which takes a function f and a variable number of maps.\n; Your function should return a map that consists of the rest of the maps conj-ed onto the first.\n; If a key occurs in more than one map, the mapping(s) from the latter (left-to-right) should be combined with the mapping in the result by calling (f val-in-result val-in-latter).\n\n; Special Restrictions:\n; merge-with\n\n(= (__ * {:a 2, :b 3, :c 4} {:a 2} {:b 2} {:c 5})\n   {:a 4, :b 6, :c 20})\n\n\t\n(= (__ - {1 10, 2 20} {1 3, 2 10, 3 15})\n   {1 7, 2 10, 3 15})\n\n\t\n(= (__ concat {:a [3], :b [6]} {:a [4 5], :c [8 9]} {:b [7]})\n   {:a [3 4 5], :b [6 7], :c [8 9]})```"}]}],"title":"4clojure - Problem 69"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"SwD8t0d32Mh","children":[{"edit-time:":1614171257615,"uid":"h4-p04ToOiF","string":"**URL:** https://www.4clojure.com/problem/70"},{"edit-time:":1614171257615,"uid":"bVRUEzU1js7","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"AdUUn1sHCoD","string":"Difficulty: Medium"},{"edit-time:":1614171257615,"uid":"cCO2EqNpgc5","string":"Topics: sorting"}]},{"edit-time:":1614171257615,"uid":"kpoSgoCWnly","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"6480lPEBVpV","string":"```clojure\n; Write a function that splits a sentence up into a sorted list of words.\n; Capitalization should not affect sort order and punctuation should be ignored.\n\n(= (__  \"Have a nice day.\")\n   [\"a\" \"day\" \"Have\" \"nice\"])\n\n\t\n(= (__  \"Clojure is a fun language!\")\n   [\"a\" \"Clojure\" \"fun\" \"is\" \"language\"])\n\n\t\n(= (__  \"Fools fall for foolish follies.\")\n   [\"fall\" \"follies\" \"foolish\" \"Fools\" \"for\"])```"}]}],"title":"4clojure - Problem 70"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"HoCgBkukIpR","children":[{"edit-time:":1614171257615,"uid":"U6Df-ZSgvyc","string":"**URL:** https://www.4clojure.com/problem/71"},{"edit-time:":1614171257615,"uid":"HpnDiHUsZN6","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"RSd1LO4M59W","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257615,"uid":"mLp0bZ0n9ZK","string":"**Syntax**:","children":[{"edit-time:":1614171257615,"uid":"0H3cx5VFqM5","string":"```clojure\n(sort ...)```"}]},{"edit-time:":1614171257615,"uid":"EjZWBQ_huuP","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"mpfRo9koTZa","string":"```clojure\n; The -> macro threads an expression x through a variable number of forms.\n; First, x is inserted as the second item in the first form, making a list of it if it is not a list already.\n; Then the first form is inserted as the second item in the second form, making a list of that form if necessary.\n; This process continues for all the forms.\n; Using -> can sometimes make your code more readable.\n\n(= (__ (sort (rest (reverse [2 5 4 1 3 6]))))\n   (-> [2 5 4 1 3 6] (reverse) (rest) (sort) (__))\n   5)```"}]}],"title":"4clojure - Problem 71"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"sWwoNpOIELF","children":[{"edit-time:":1614171257615,"uid":"EvfSftqa-28","string":"**URL:** https://www.4clojure.com/problem/72"},{"edit-time:":1614171257615,"uid":"SubX2PywoXM","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"BlLQAauA0hJ","string":"Difficulty: Elementary"}]},{"edit-time:":1614171257615,"uid":"D1X8tx-E7SE","string":"**Syntax**:","children":[{"edit-time:":1614171257615,"uid":"TpYOGBbZKXR","string":"```clojure\n(drop ...)```"},{"edit-time:":1614171257615,"uid":"zVugOxq3PMU","string":"```clojure\n(+ ...)```"}]},{"edit-time:":1614171257615,"uid":"bTT-M5kAubL","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"M-QwBq5iix2","string":"```clojure\n; The ->> macro threads an expression x through a variable number of forms.\n; First, x is inserted as the last item in the first form, making a list of it if it is not a list already.\n; Then the first form is inserted as the last item in the second form, making a list of that form if necessary.\n; This process continues for all the forms.\n; Using ->> can sometimes make your code more readable.\n\n(= (__ (map inc (take 3 (drop 2 [2 5 4 1 3 6]))))\n   (->> [2 5 4 1 3 6] (drop 2) (take 3) (map inc) (__))\n   11)```"}]}],"title":"4clojure - Problem 72"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"1JcF_bL50Eh","children":[{"edit-time:":1614171257615,"uid":"HFFcU_MT6Bx","string":"**URL:** https://www.4clojure.com/problem/73"},{"edit-time:":1614171257615,"uid":"7ZUNMBEpttm","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"yPV8ad5iDa9","string":"Difficulty: Hard"},{"edit-time:":1614171257615,"uid":"V_sJLhFUrE4","string":"Topics: game"}]},{"edit-time:":1614171257615,"uid":"oVSs6vbA3XB","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"Y03aZ_Qhpoz","string":"```clojure\n; A tic-tac-toe board is represented by a two dimensional vector.\n; X is represented by :x, O is represented by :o, and empty is represented by :e.\n; A player wins by placing three Xs or three Os in a horizontal, vertical, or diagonal row.\n; Write a function which analyzes a tic-tac-toe board and returns :x if X has won, :o if O has won, and nil if neither player has won.\n\n(= nil (__ [[:e :e :e]\n            [:e :e :e]\n            [:e :e :e]]))\n\n\t\n(= :x (__ [[:x :e :o]\n           [:x :e :e]\n           [:x :e :o]]))\n\n\t\n(= :o (__ [[:e :x :e]\n           [:o :o :o]\n           [:x :e :x]]))\n\n\t\n(= nil (__ [[:x :e :o]\n            [:x :x :e]\n            [:o :x :o]]))\n\n\t\n(= :x (__ [[:x :e :e]\n           [:o :x :e]\n           [:o :e :x]]))\n\n\t\n(= :o (__ [[:x :e :o]\n           [:x :o :e]\n           [:o :e :x]]))\n\n\t\n(= nil (__ [[:x :o :x]\n            [:x :o :x]\n            [:o :x :o]]))```"}]}],"title":"4clojure - Problem 73"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"7fS91-p2Iob","children":[{"edit-time:":1614171257615,"uid":"7OaoyxjfbYy","string":"**URL:** https://www.4clojure.com/problem/74"},{"edit-time:":1614171257615,"uid":"M7gHe1-OzKQ","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"ESP4_BQd6qD","string":"Difficulty: Medium"}]},{"edit-time:":1614171257615,"uid":"FsLBCVLHU5f","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"jNSWCx9eGVw","string":"```clojure\n; Given a string of comma separated integers, write a function which returns a new comma separated string that only contains the numbers which are perfect squares.\n\n(= (__ \"4,5,6,7,8,9\") \"4,9\")\n\n\t\n(= (__ \"15,16,25,36,37\") \"16,25,36\")```"}]}],"title":"4clojure - Problem 74"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"RZ7790ZTC1g","children":[{"edit-time:":1614171257615,"uid":"E0hbeScPlwe","string":"**URL:** https://www.4clojure.com/problem/75"},{"edit-time:":1614171257615,"uid":"kfejab9uDQE","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"bYBM6QEZxx-","string":"Difficulty: Medium"}]},{"edit-time:":1614171257615,"uid":"d4aq7tAltgY","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"_G-oMWXd__H","string":"```clojure\n; Two numbers are coprime if their greatest common divisor equals 1.\n; Euler's totient function f(x) is defined as the number of positive integers less than x which are coprime to x.\n; The special case f(1) equals 1.\n; Write a function which calculates Euler's totient function.\n\n(= (__ 1) 1)\n\n\t\n(= (__ 10) (count '(1 3 7 9)) 4)\n\n\t\n(= (__ 40) 16)\n\n\t\n(= (__ 99) 60)```"}]}],"title":"4clojure - Problem 75"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"Z_wj3xqavMI","children":[{"edit-time:":1614171257615,"uid":"DxPHdNOu_YY","string":"**URL:** https://www.4clojure.com/problem/76"},{"edit-time:":1614171257615,"uid":"tekxWsLiMJc","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"j9ATCfqp_Ku","string":"Difficulty: Medium"},{"edit-time:":1614171257615,"uid":"mINrtbCjySO","string":"Topics: recursion"}]},{"edit-time:":1614171257615,"uid":"rqKOBOKiDTH","string":"**Syntax**:","children":[{"edit-time:":1614171257615,"uid":"Ht3-GwyEjJe","string":"```clojure\n(trampoline ...)```"}]},{"edit-time:":1614171257615,"uid":"-KG1shHjWQi","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"DHfiklSJ61F","string":"```clojure\n; The trampoline function takes a function f and a variable number of parameters.\n; Trampoline calls f with any parameters that were supplied.\n; If f returns a function, trampoline calls that function with no arguments.\n; This is repeated, until the return value is not a function, and then trampoline returns that non-function value.\n; This is useful for implementing mutually recursive algorithms in a way that won't consume the stack.\n\n(= __\n   (letfn\n     [(foo [x y] #(bar (conj x y) y))\n      (bar [x y] (if (> (last x) 10)\n                   x\n                   #(foo x (+ 2 y))))]\n     (trampoline foo [] 1)))```"}]}],"title":"4clojure - Problem 76"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"UlCEPTIQ8Sv","children":[{"edit-time:":1614171257615,"uid":"oGfl5DG9BID","string":"**URL:** https://www.4clojure.com/problem/77"},{"edit-time:":1614171257615,"uid":"Rf_W_9H5TZV","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"KwF_fO2sNWf","string":"Difficulty: Medium"}]},{"edit-time:":1614171257615,"uid":"f-iS2jRwU6S","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"fVolSJS9qit","string":"```clojure\n; Write a function which finds all the anagrams in a vector of words.\n; A word x is an anagram of word y if all the letters in x can be rearranged in a different order to form y.\n; Your function should return a set of sets, where each sub-set is a group of words which are anagrams of each other.\n; Each sub-set should have at least two words.\n; Words without any anagrams should not be included in the result.\n\n(= (__ [\"meat\" \"mat\" \"team\" \"mate\" \"eat\"])\n   #{#{\"meat\" \"team\" \"mate\"}})\n\n\t\n(= (__ [\"veer\" \"lake\" \"item\" \"kale\" \"mite\" \"ever\"])\n   #{#{\"veer\" \"ever\"} #{\"lake\" \"kale\"} #{\"mite\" \"item\"}})```"}]}],"title":"4clojure - Problem 77"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"K9GHd-W679U","children":[{"edit-time:":1614171257615,"uid":"pI4Qgi4WABs","string":"**URL:** https://www.4clojure.com/problem/78"},{"edit-time:":1614171257615,"uid":"gwvqgP2ztU4","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"aLFENUd1244","string":"Difficulty: Medium"},{"edit-time:":1614171257615,"uid":"S4IZ9JAI39P","string":"Topics: core-functions"}]},{"edit-time:":1614171257615,"uid":"DtQw-X0QhiT","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"CzQJ_voWvbM","string":"```clojure\n; Reimplement the function described in \"Intro to Trampoline\".\n\n; Special Restrictions:\n; trampoline\n\n(= (letfn [(triple [x] #(sub-two (* 3 x)))\n          (sub-two [x] #(stop?(- x 2)))\n          (stop? [x] (if (> x 50) x #(triple x)))]\n    (__ triple 2))\n  82)\n\n\t\n(= (letfn [(my-even? [x] (if (zero? x) true #(my-odd? (dec x))))\n          (my-odd? [x] (if (zero? x) false #(my-even? (dec x))))]\n    (map (partial __ my-even?) (range 6)))\n  [true false true false true false])```"}]}],"title":"4clojure - Problem 78"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"Zpf5S7QsFqa","children":[{"edit-time:":1614171257615,"uid":"thrG6AGJELS","string":"**URL:** https://www.4clojure.com/problem/79"},{"edit-time:":1614171257615,"uid":"NJ2qfQJPWkc","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"VmlwQx7KXda","string":"Difficulty: Hard"},{"edit-time:":1614171257615,"uid":"StxkYAz4ZOa","string":"Topics: graph-theory"}]},{"edit-time:":1614171257615,"uid":"epNLKHded4l","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"TU5GAkcW1-K","string":"```clojure\n; Write a function which calculates the sum of the minimal path through a triangle.\n; The triangle is represented as a collection of vectors.\n; The path should start at the top of the triangle and move to an adjacent number on the next row until the bottom of the triangle is reached.\n\n(= 7 (__ '([1]\n          [2 4]\n         [5 1 4]\n        [2 3 4 5]))) ; 1->2->1->3\n\n\t\n(= 20 (__ '([3]\n           [2 4]\n          [1 9 3]\n         [9 9 2 4]\n        [4 6 6 7 8]\n       [5 7 3 5 1 4]))) ; 3->4->3->2->7->1```"}]}],"title":"4clojure - Problem 79"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"-uXQB3NBQwq","children":[{"edit-time:":1614171257615,"uid":"OTQ1XVoy_KA","string":"**URL:** https://www.4clojure.com/problem/80"},{"edit-time:":1614171257615,"uid":"q1e47--T0JK","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"27MMtAqZois","string":"Difficulty: Medium"}]},{"edit-time:":1614171257615,"uid":"oZxF3RJgokc","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"eMVQcDMz8gf","string":"```clojure\n; A number is \"perfect\" if the sum of its divisors equal the number itself.\n; 6 is a perfect number because 1+2+3=6.\n; Write a function which returns true for perfect numbers and false otherwise.\n\n(= (__ 6) true)\n\n\t\n(= (__ 7) false)\n\n\t\n(= (__ 496) true)\n\n\t\n(= (__ 500) false)\n\n\t\n(= (__ 8128) true)```"}]}],"title":"4clojure - Problem 80"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"SwfPw2_Vn17","children":[{"edit-time:":1614171257615,"uid":"X9nG5S4whbn","string":"**URL:** https://www.4clojure.com/problem/81"},{"edit-time:":1614171257615,"uid":"I8hfbtiKAIL","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"qEXk5GR-yHM","string":"Difficulty: Easy"},{"edit-time:":1614171257615,"uid":"NFT1i7Qbq8B","string":"Topics: set-theory"}]},{"edit-time:":1614171257615,"uid":"dvHpKAnIdkY","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"VNzHnrA6AW0","string":"```clojure\n; Write a function which returns the intersection of two sets.\n; The intersection is the sub-set of items that each set has in common.\n\n; Special Restrictions:\n; intersection\n\n(= (__ #{0 1 2 3} #{2 3 4 5}) #{2 3})\n\n\t\n(= (__ #{0 1 2} #{3 4 5}) #{})\n\n\t\n(= (__ #{:a :b :c :d} #{:c :e :a :f :d}) #{:a :c :d})```"}]}],"title":"4clojure - Problem 81"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"PePMkzncrmU","children":[{"edit-time:":1614171257615,"uid":"bsI1HgEoQAc","string":"**URL:** https://www.4clojure.com/problem/82"},{"edit-time:":1614171257615,"uid":"uPa68LTrcV2","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"X590xZy8x4q","string":"Difficulty: Hard"},{"edit-time:":1614171257615,"uid":"vqarScJafEA","string":"Topics: seqs"}]},{"edit-time:":1614171257615,"uid":"WleLr9gnw5f","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"lZaHiscOoE0","string":"```clojure\n; A word chain consists of a set of words ordered so that each word differs by only one letter from the words directly before and after it.\n; The one letter difference can be either an insertion, a deletion, or a substitution.\n; Here is an example word chain:.\n; \n; \n; cat -> cot -> coat -> oat -> hat -> hot -> hog -> dog\n; \n; Write a function which takes a sequence of words, and returns true if they can be arranged into one continous word chain, and false if they cannot.\n\n(= true (__ #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"}))\n\n\t\n(= false (__ #{\"cot\" \"hot\" \"bat\" \"fat\"}))\n\n\t\n(= false (__ #{\"to\" \"top\" \"stop\" \"tops\" \"toss\"}))\n\n\t\n(= true (__ #{\"spout\" \"do\" \"pot\" \"pout\" \"spot\" \"dot\"}))\n\n\t\n(= true (__ #{\"share\" \"hares\" \"shares\" \"hare\" \"are\"}))\n\n\t\n(= false (__ #{\"share\" \"hares\" \"hare\" \"are\"}))```"}]}],"title":"4clojure - Problem 82"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"Vz_NbA31XEY","children":[{"edit-time:":1614171257615,"uid":"K-t4x7RcY41","string":"**URL:** https://www.4clojure.com/problem/83"},{"edit-time:":1614171257615,"uid":"C9TcooW4B62","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"fglSiBmIbW8","string":"Difficulty: Easy"}]},{"edit-time:":1614171257615,"uid":"cmkLBvMXrJi","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"Xt5pZcnNmqH","string":"```clojure\n; Write a function which takes a variable number of booleans.\n; Your function should return true if some of the parameters are true, but not all of the parameters are true.\n; Otherwise your function should return false.\n\n(= false (__ false false))\n\n\t\n(= true (__ true false))\n\n\t\n(= false (__ true))\n\n\t\n(= true (__ false true false))\n\n\t\n(= false (__ true true true))\n\n\t\n(= true (__ true true true false))```"}]}],"title":"4clojure - Problem 83"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"ejax9QFX0bS","children":[{"edit-time:":1614171257615,"uid":"kZgRGdSY8_7","string":"**URL:** https://www.4clojure.com/problem/84"},{"edit-time:":1614171257615,"uid":"wZs108TS1iS","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"EB8kCX2L7uy","string":"Difficulty: Hard"},{"edit-time:":1614171257615,"uid":"Um6nWQEYCxd","string":"Topics: set-theory"}]},{"edit-time:":1614171257615,"uid":"dZfQ49XIhCU","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"FIGCZaQuByN","string":"```clojure\n; Write a function which generates the transitive closure of a binary relation.\n; The relation will be represented as a set of 2 item vectors.\n\n(let [divides #{[8 4] [9 3] [4 2] [27 9]}]\n  (= (__ divides) #{[4 2] [8 4] [8 2] [9 3] [27 9] [27 3]}))\n\n\t\n(let [more-legs\n      #{[\"cat\" \"man\"] [\"man\" \"snake\"] [\"spider\" \"cat\"]}]\n  (= (__ more-legs)\n     #{[\"cat\" \"man\"] [\"cat\" \"snake\"] [\"man\" \"snake\"]\n       [\"spider\" \"cat\"] [\"spider\" \"man\"] [\"spider\" \"snake\"]}))\n\n\t\n(let [progeny\n      #{[\"father\" \"son\"] [\"uncle\" \"cousin\"] [\"son\" \"grandson\"]}]\n  (= (__ progeny)\n     #{[\"father\" \"son\"] [\"father\" \"grandson\"]\n       [\"uncle\" \"cousin\"] [\"son\" \"grandson\"]}))```"}]}],"title":"4clojure - Problem 84"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"NAKMWKX0JZ9","children":[{"edit-time:":1614171257615,"uid":"Bci84J-3Rbo","string":"**URL:** https://www.4clojure.com/problem/85"},{"edit-time:":1614171257615,"uid":"2xZhoGtfqrd","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"WmVU-Y_A5aW","string":"Difficulty: Medium"},{"edit-time:":1614171257615,"uid":"IGSUALEnJ0v","string":"Topics: set-theory"}]},{"edit-time:":1614171257615,"uid":"FJi0RbSpJVV","string":"**Syntax**:","children":[{"edit-time:":1614171257615,"uid":"cDOC7c7XgXo","string":"```clojure\n(into ...)```"}]},{"edit-time:":1614171257615,"uid":"iTfgLyOOjkD","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"K3-8GX3qMGN","string":"```clojure\n; Write a function which generates the power set of a given set.\n; The power set of a set x is the set of all subsets of x, including the empty set and x itself.\n\n(= (__ #{1 :a}) #{#{1 :a} #{:a} #{} #{1}})\n\n\t\n(= (__ #{}) #{#{}})\n\n\t\n(= (__ #{1 2 3})\n   #{#{} #{1} #{2} #{3} #{1 2} #{1 3} #{2 3} #{1 2 3}})\n\n\t\n(= (count (__ (into #{} (range 10)))) 1024)```"}]}],"title":"4clojure - Problem 85"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"-QCL5ozEFCs","children":[{"edit-time:":1614171257615,"uid":"hI4wRbtPop3","string":"**URL:** https://www.4clojure.com/problem/86"},{"edit-time:":1614171257615,"uid":"_-BxOaYfvX7","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"PUy8VK7tQDh","string":"Difficulty: Medium"},{"edit-time:":1614171257615,"uid":"ncTFHf1gW5T","string":"Topics: math"}]},{"edit-time:":1614171257615,"uid":"ladR1N51fL3","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"1G_SYVka-wn","string":"```clojure\n; Happy numbers are positive integers that follow a particular formula: take each individual digit, square it, and then sum the squares to get a new number.\n; Repeat with the new number and eventually, you might get to a number whose squared sum is 1.\n; This is a happy number.\n; An unhappy number (or sad number) is one that loops endlessly.\n; Write a function that determines if a number is happy or not.\n\n(= (__ 7) true)\n\n\t\n(= (__ 986543210) true)\n\n\t\n(= (__ 2) false)\n\n\t\n(= (__ 3) false)```"}]}],"title":"4clojure - Problem 86"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"m_W6DCHpMsK","children":[{"edit-time:":1614171257615,"uid":"Sowzb2lL2KV","string":"**URL:** https://www.4clojure.com/problem/88"},{"edit-time:":1614171257615,"uid":"4H1IoXIFtVQ","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"_sIU_jRanPn","string":"Difficulty: Easy"},{"edit-time:":1614171257615,"uid":"8_3SA6WZXzj","string":"Topics: set-theory"}]},{"edit-time:":1614171257615,"uid":"BsKnYf_SJU8","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"ug2553bvrLd","string":"```clojure\n; Write a function which returns the symmetric difference of two sets.\n; The symmetric difference is the set of items belonging to one but not both of the two sets.\n\n(= (__ #{1 2 3 4 5 6} #{1 3 5 7}) #{2 4 6 7})\n\n\t\n(= (__ #{:a :b :c} #{}) #{:a :b :c})\n\n\t\n(= (__ #{} #{4 5 6}) #{4 5 6})\n\n\t\n(= (__ #{[1 2] [2 3]} #{[2 3] [3 4]}) #{[1 2] [3 4]})```"}]}],"title":"4clojure - Problem 88"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"EphktWrnQLw","children":[{"edit-time:":1614171257615,"uid":"_CUY8Lo4OLR","string":"**URL:** https://www.4clojure.com/problem/89"},{"edit-time:":1614171257615,"uid":"zleGvaa70Tb","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"osfrPceneF1","string":"Difficulty: Hard"},{"edit-time:":1614171257615,"uid":"u8DuUfAWjAh","string":"Topics: graph-theory"}]},{"edit-time:":1614171257615,"uid":"dH6iRiP4Qc1","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"jNKWiCx-Xix","string":"```clojure\n; Starting with a graph you must write a function that returns true if it is possible to make a tour of the graph in which every edge is visited exactly once.\n; \n; The graph is represented by a vector of tuples, where each tuple represents a single edge.\n; \n; The rules are:\n; \n; - You can start at any node.\n; - You must visit each edge exactly once.\n; - All edges are undirected.\n\n(= true (__ [[:a :b]]))\n\n\t\n(= false (__ [[:a :a] [:b :b]]))\n\n\t\n(= false (__ [[:a :b] [:a :b] [:a :c] [:c :a]\n               [:a :d] [:b :d] [:c :d]]))\n\n\t\n(= true (__ [[1 2] [2 3] [3 4] [4 1]]))\n\n\t\n(= true (__ [[:a :b] [:a :c] [:c :b] [:a :e]\n              [:b :e] [:a :d] [:b :d] [:c :e]\n              [:d :e] [:c :f] [:d :f]]))\n\n\t\n(= false (__ [[1 2] [2 3] [2 4] [2 5]]))```"}]}],"title":"4clojure - Problem 89"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"YEDj2RbdDKW","children":[{"edit-time:":1614171257615,"uid":"Ogb6VAeTdzV","string":"**URL:** https://www.4clojure.com/problem/90"},{"edit-time:":1614171257615,"uid":"sftLcghHr_C","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"2C2y2S5f_Uy","string":"Difficulty: Easy"},{"edit-time:":1614171257615,"uid":"t-aAS8og8ui","string":"Topics: set-theory"}]},{"edit-time:":1614171257615,"uid":"QQgdNRs_Gvt","string":"**Problem:**","children":[{"edit-time:":1614171257615,"uid":"InIV_5_7mii","string":"```clojure\n; Write a function which calculates the Cartesian product of two sets.\n\n(= (__ #{\"ace\" \"king\" \"queen\"} #{\"♠\" \"♥\" \"♦\" \"♣\"})\n   #{[\"ace\"   \"♠\"] [\"ace\"   \"♥\"] [\"ace\"   \"♦\"] [\"ace\"   \"♣\"]\n     [\"king\"  \"♠\"] [\"king\"  \"♥\"] [\"king\"  \"♦\"] [\"king\"  \"♣\"]\n     [\"queen\" \"♠\"] [\"queen\" \"♥\"] [\"queen\" \"♦\"] [\"queen\" \"♣\"]})\n\n\t\n(= (__ #{1 2 3} #{4 5})\n   #{[1 4] [2 4] [3 4] [1 5] [2 5] [3 5]})\n\n\t\n(= 300 (count (__ (into #{} (range 10))\n                  (into #{} (range 30)))))```"}]}],"title":"4clojure - Problem 90"},{"create-time":1614171257615,"edit-time:":1614171257615,"uid":"1JFkGhqqBVm","children":[{"edit-time:":1614171257615,"uid":"RKdcQ6vb6mh","string":"**URL:** https://www.4clojure.com/problem/91"},{"edit-time:":1614171257615,"uid":"lF_7BDd0TUT","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257615,"uid":"L--qkJZWZem","string":"Difficulty: Hard"},{"edit-time:":1614171257615,"uid":"2FVuoy3qeYm","string":"Topics: graph-theory"}]},{"edit-time:":1614171257616,"uid":"0WvErgRkDUr","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"4_eKDSpQA2r","string":"```clojure\n; Given a graph, determine whether the graph is connected.\n; A connected graph is such that a path exists between any two given nodes.\n; \n; \n; -Your function must return true if the graph is connected and false otherwise.\n; \n; -You will be given a set of tuples representing the edges of a graph.\n; Each member of a tuple being a vertex/node in the graph.\n; \n; \n; -Each edge is undirected (can be traversed either direction).\n\n(= true (__ #{[:a :a]}))\n\n\t\n(= true (__ #{[:a :b]}))\n\n\t\n(= false (__ #{[1 2] [2 3] [3 1]\n               [4 5] [5 6] [6 4]}))\n\n\t\n(= true (__ #{[1 2] [2 3] [3 1]\n              [4 5] [5 6] [6 4] [3 4]}))\n\n\t\n(= false (__ #{[:a :b] [:b :c] [:c :d]\n               [:x :y] [:d :a] [:b :e]}))\n\n\t\n(= true (__ #{[:a :b] [:b :c] [:c :d]\n              [:x :y] [:d :a] [:b :e] [:x :a]}))```"}]}],"title":"4clojure - Problem 91"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"CdXs_odhVxj","children":[{"edit-time:":1614171257616,"uid":"YKDhpsm5X7k","string":"**URL:** https://www.4clojure.com/problem/92"},{"edit-time:":1614171257616,"uid":"B1jXos3UIqf","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"NWo0bMRr307","string":"Difficulty: Hard"},{"edit-time:":1614171257616,"uid":"xqu5Bkev6na","string":"Topics: strings math"}]},{"edit-time:":1614171257616,"uid":"hziQiHW9QL_","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"NV7Z0i2w8i9","string":"```clojure\n; Roman numerals are easy to recognize, but not everyone knows all the rules necessary to work with them.\n; Write a function to parse a Roman-numeral string and return the number it represents.\n; \n; \n; You can assume that the input will be well-formed, in upper-case, and follow the subtractive principle.\n; You don't need to handle any numbers greater than MMMCMXCIX (3999), the largest number representable with ordinary letters.\n\n(= 14 (__ \"XIV\"))\n\n\t\n(= 827 (__ \"DCCCXXVII\"))\n\n\t\n(= 3999 (__ \"MMMCMXCIX\"))\n\n\t\n(= 48 (__ \"XLVIII\"))```"}]}],"title":"4clojure - Problem 92"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"RmqaECQf4VN","children":[{"edit-time:":1614171257616,"uid":"iYqtfmdDnWg","string":"**URL:** https://www.4clojure.com/problem/93"},{"edit-time:":1614171257616,"uid":"VTjFwz9YBuQ","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"KJPi4xvaFQK","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"uiwKMct9Df_","string":"Topics: seqs"}]},{"edit-time:":1614171257616,"uid":"58RHI0z2ooE","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"byODRgkUod0","string":"```clojure\n; Write a function which flattens any nested combination of sequential things (lists, vectors, etc.\n; ), but maintains the lowest level sequential items.\n; The result should be a sequence of sequences with only one level of nesting.\n\n(= (__ [[\"Do\"] [\"Nothing\"]])\n   [[\"Do\"] [\"Nothing\"]])\n\n\t\n(= (__ [[[[:a :b]]] [[:c :d]] [:e :f]])\n   [[:a :b] [:c :d] [:e :f]])\n\n\t\n(= (__ '((1 2)((3 4)((((5 6)))))))\n   '((1 2)(3 4)(5 6)))```"}]}],"title":"4clojure - Problem 93"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"wZzbLh--R0-","children":[{"edit-time:":1614171257616,"uid":"qKhHflX6xpo","string":"**URL:** https://www.4clojure.com/problem/94"},{"edit-time:":1614171257616,"uid":"HW_PZg7vtHy","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"TbRN-gX_yk-","string":"Difficulty: Hard"},{"edit-time:":1614171257616,"uid":"v67aDAenRmk","string":"Topics: game"}]},{"edit-time:":1614171257616,"uid":"OdpwO_Ee1b5","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"_-OGk4kLNGH","string":"```clojure\n; The game of life is a cellular automaton devised by mathematician John Conway.\n; \n; The 'board' consists of both live (#) and dead ( ) cells.\n; Each cell interacts with its eight neighbours (horizontal, vertical, diagonal), and its next state is dependent on the following rules:.\n; \n; \n; 1) Any live cell with fewer than two live neighbours dies, as if caused by under-population.\n; 2) Any live cell with two or three live neighbours lives on to the next generation.\n; 3) Any live cell with more than three live neighbours dies, as if by overcrowding.\n; 4) Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\n; \n; Write a function that accepts a board, and returns a board representing the next generation of cells.\n\n(= (__ [\"      \"  \n        \" ##   \"\n        \" ##   \"\n        \"   ## \"\n        \"   ## \"\n        \"      \"])\n   [\"      \"  \n    \" ##   \"\n    \" #    \"\n    \"    # \"\n    \"   ## \"\n    \"      \"])\n\n\t\n(= (__ [\"     \"\n        \"     \"\n        \" ### \"\n        \"     \"\n        \"     \"])\n   [\"     \"\n    \"  #  \"\n    \"  #  \"\n    \"  #  \"\n    \"     \"])\n\n\t\n(= (__ [\"      \"\n        \"      \"\n        \"  ### \"\n        \" ###  \"\n        \"      \"\n        \"      \"])\n   [\"      \"\n    \"   #  \"\n    \" #  # \"\n    \" #  # \"\n    \"  #   \"\n    \"      \"])```"}]}],"title":"4clojure - Problem 94"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"FdaOxR-H-pm","children":[{"edit-time:":1614171257616,"uid":"RA6gVOwOlCS","string":"**URL:** https://www.4clojure.com/problem/95"},{"edit-time:":1614171257616,"uid":"T3iM7iAhGIh","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"7IDFaWxrqLz","string":"Difficulty: Easy"},{"edit-time:":1614171257616,"uid":"1AV6ixCeilv","string":"Topics: trees"}]},{"edit-time:":1614171257616,"uid":"2dIpLtBCIZO","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"c094lfyt069","string":"```clojure\n; Write a predicate which checks whether or not a given sequence represents a binary tree.\n; Each node in the tree must have a value, a left child, and a right child.\n\n(= (__ '(:a (:b nil nil) nil))\n   true)\n\n\t\n(= (__ '(:a (:b nil nil)))\n   false)\n\n\t\n(= (__ [1 nil [2 [3 nil nil] [4 nil nil]]])\n   true)\n\n\t\n(= (__ [1 [2 nil nil] [3 nil nil] [4 nil nil]])\n   false)\n\n\t\n(= (__ [1 [2 [3 [4 nil nil] nil] nil] nil])\n   true)\n\n\t\n(= (__ [1 [2 [3 [4 false nil] nil] nil] nil])\n   false)\n\n\t\n(= (__ '(:a nil ()))\n   false)```"}]}],"title":"4clojure - Problem 95"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"IbEa57NFcBa","children":[{"edit-time:":1614171257616,"uid":"7qQHTRnmvv7","string":"**URL:** https://www.4clojure.com/problem/96"},{"edit-time:":1614171257616,"uid":"gwm7gAgkJCu","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"2TikcMk5a65","string":"Difficulty: Easy"},{"edit-time:":1614171257616,"uid":"OuModCdgfrC","string":"Topics: trees"}]},{"edit-time:":1614171257616,"uid":"UZDpubv_CaS","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"3NO2wJ27HLe","string":"```clojure\n; Let us define a binary tree as \"symmetric\" if the left half of the tree is the mirror image of the right half of the tree.\n; Write a predicate to determine whether or not a given binary tree is symmetric.\n; (see To Tree, or not to Tree for a reminder on the tree representation we're using).\n\n(= (__ '(:a (:b nil nil) (:b nil nil))) true)\n\n\t\n(= (__ '(:a (:b nil nil) nil)) false)\n\n\t\n(= (__ '(:a (:b nil nil) (:c nil nil))) false)\n\n\t\n(= (__ [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]])\n   true)\n\n\t\n(= (__ [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [5 nil nil] [6 nil nil]]] nil]])\n   false)\n\n\t\n(= (__ [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [6 nil nil] nil]] nil]])\n   false)```"}]}],"title":"4clojure - Problem 96"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"aDx8FEiIQ3o","children":[{"edit-time:":1614171257616,"uid":"mr8mTHSAhzH","string":"**URL:** https://www.4clojure.com/problem/97"},{"edit-time:":1614171257616,"uid":"eGJFBQfvM_Z","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"5hYtjfPz4K3","string":"Difficulty: Easy"}]},{"edit-time:":1614171257616,"uid":"bRVsC49yl14","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"rH72GUASfhd","string":"```clojure\n; Pascal's triangle is a triangle of numbers computed using the following rules:\n; \n; - The first row is 1.\n; - Each successive row is computed by adding together adjacent numbers in the row above, and adding a 1 to the beginning and end of the row.\n; \n; Write a function which returns the nth row of Pascal's Triangle.\n\n(= (__ 1) [1])\n\n\t\n(= (map __ (range 1 6))\n   [     [1]\n        [1 1]\n       [1 2 1]\n      [1 3 3 1]\n     [1 4 6 4 1]])\n\n\t\n(= (__ 11)\n   [1 10 45 120 210 252 210 120 45 10 1])```"}]}],"title":"4clojure - Problem 97"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"et1y3XjHn2N","children":[{"edit-time:":1614171257616,"uid":"oeMA7PSuNuj","string":"**URL:** https://www.4clojure.com/problem/98"},{"edit-time:":1614171257616,"uid":"OX_vro0YC1t","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"MDllzPBF5ff","string":"Difficulty: Medium"}]},{"edit-time:":1614171257616,"uid":"tlXu6Z_4IeZ","string":"**Syntax**:","children":[{"edit-time:":1614171257616,"uid":"lJF620D7qJb","string":"```clojure\n(rem ...)```"},{"edit-time:":1614171257616,"uid":"DqOrlmPFR18","string":"```clojure\n(identity ...)```"},{"edit-time:":1614171257616,"uid":"RcXJ-LnoUe0","string":"```clojure\n(constantly ...)```"}]},{"edit-time:":1614171257616,"uid":"2lccMHDISYs","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"M7f63GwvmVo","string":"```clojure\n; A function f defined on a domain D induces an equivalence relation on D, as follows: a is equivalent to b with respect to f if and only if (f a) is equal to (f b).\n; Write a function with arguments f and D that computes the equivalence classes of D with respect to f.\n\n(= (__ #(* % %) #{-2 -1 0 1 2})\n   #{#{0} #{1 -1} #{2 -2}})\n\n\t\n(= (__ #(rem % 3) #{0 1 2 3 4 5 })\n   #{#{0 3} #{1 4} #{2 5}})\n\n\t\n(= (__ identity #{0 1 2 3 4})\n   #{#{0} #{1} #{2} #{3} #{4}})\n\n\t\n(= (__ (constantly true) #{0 1 2 3 4})\n   #{#{0 1 2 3 4}})```"}]}],"title":"4clojure - Problem 98"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"G7-yZGIpef_","children":[{"edit-time:":1614171257616,"uid":"iWmsRacig0U","string":"**URL:** https://www.4clojure.com/problem/99"},{"edit-time:":1614171257616,"uid":"oKFlx6QfxSp","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"oS4ActFGUDF","string":"Difficulty: Easy"},{"edit-time:":1614171257616,"uid":"waFNONq9O2J","string":"Topics: math seqs"}]},{"edit-time:":1614171257616,"uid":"TwnhD_n4K0c","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"HG-q38nuag-","string":"```clojure\n; Write a function which multiplies two numbers and returns the result as a sequence of its digits.\n\n(= (__ 1 1) [1])\n\n\t\n(= (__ 99 9) [8 9 1])\n\n\t\n(= (__ 999 99) [9 8 9 0 1])```"}]}],"title":"4clojure - Problem 99"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"_R2U0uRzp68","children":[{"edit-time:":1614171257616,"uid":"fjlvGij5_RZ","string":"**URL:** https://www.4clojure.com/problem/100"},{"edit-time:":1614171257616,"uid":"3HWIxoXScQN","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"jIstBmidCVu","string":"Difficulty: Easy"},{"edit-time:":1614171257616,"uid":"2pgs_hPQ2If","string":"Topics: math"}]},{"edit-time:":1614171257616,"uid":"E0Br74J75MC","string":"**Syntax**:","children":[{"edit-time:":1614171257616,"uid":"MkjJWFqm6Dn","string":"```clojure\n(== ...)```"}]},{"edit-time:":1614171257616,"uid":"FeGBF30iJfK","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"Me-cvlxdEOP","string":"```clojure\n; Write a function which calculates the least common multiple.\n; Your function should accept a variable number of positive integers or ratios.\n\n(== (__ 2 3) 6)\n\n\t\n(== (__ 5 3 7) 105)\n\n\t\n(== (__ 1/3 2/5) 2)\n\n\t\n(== (__ 3/4 1/6) 3/2)\n\n\t\n(== (__ 7 5/7 2 3/5) 210)```"}]}],"title":"4clojure - Problem 100"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"BgouHwvD17K","children":[{"edit-time:":1614171257616,"uid":"c8ZKD3KDgcH","string":"**URL:** https://www.4clojure.com/problem/101"},{"edit-time:":1614171257616,"uid":"tFj-JaMTK7T","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"ioC94fNeSB7","string":"Difficulty: Hard"},{"edit-time:":1614171257616,"uid":"Ln8kS-3B7KQ","string":"Topics: seqs"}]},{"edit-time:":1614171257616,"uid":"QIidS3VdQX7","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"SqLKbei4CzY","string":"```clojure\n; Given two sequences x and y, calculate the Levenshtein distance of x and y, i.\n; e.\n; the minimum number of edits needed to transform x into y.\n; The allowed edits are:.\n; \n; \n; - insert a single item\n; - delete a single item\n; - replace a single item with another item\n; \n; WARNING: Some of the test cases may timeout if you write an inefficient solution!\n\n(= (__ \"kitten\" \"sitting\") 3)\n\n\t\n(= (__ \"closure\" \"clojure\") (__ \"clojure\" \"closure\") 1)\n\n\t\n(= (__ \"xyx\" \"xyyyx\") 2)\n\n\t\n(= (__ \"\" \"123456\") 6)\n\n\t\n(= (__ \"Clojure\" \"Clojure\") (__ \"\" \"\") (__ [] []) 0)\n\n\t\n(= (__ [1 2 3 4] [0 2 3 4 5]) 2)\n\n\t\n(= (__ '(:a :b :c :d) '(:a :d)) 2)\n\n\t\n(= (__ \"ttttattttctg\" \"tcaaccctaccat\") 10)\n\n\t\n(= (__ \"gaattctaatctc\" \"caaacaaaaaattt\") 9)```"}]}],"title":"4clojure - Problem 101"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"3HMDBV3aSSi","children":[{"edit-time:":1614171257616,"uid":"dpLWabodgt8","string":"**URL:** https://www.4clojure.com/problem/102"},{"edit-time:":1614171257616,"uid":"PMrRWNO0Ukb","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"aqXGQSXeCcm","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"JRbC04CJ-ih","string":"Topics: strings"}]},{"edit-time:":1614171257616,"uid":"TlqSEmCenp6","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"6OkJKkI5VbE","string":"```clojure\n; When working with java, you often need to create an object with fieldsLikeThis, but you'd rather work with a hashmap that has :keys-like-this until it's time to convert.\n; Write a function which takes lower-case hyphen-separated strings and converts them to camel-case strings.\n\n(= (__ \"something\") \"something\")\n\n\t\n(= (__ \"multi-word-key\") \"multiWordKey\")\n\n\t\n(= (__ \"leaveMeAlone\") \"leaveMeAlone\")```"}]}],"title":"4clojure - Problem 102"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"FdQL6QRje7K","children":[{"edit-time:":1614171257616,"uid":"JP8iXZ_p96s","string":"**URL:** https://www.4clojure.com/problem/103"},{"edit-time:":1614171257616,"uid":"cCkcKqof5fE","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"7hPQMwCDK34","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"mxGnKJINOLP","string":"Topics: seqs combinatorics"}]},{"edit-time:":1614171257616,"uid":"ZsqCASQFyi4","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"3Z9CBB5_RKg","string":"```clojure\n; Given a sequence S consisting of n elements generate all k-combinations of S, i.\n; e.\n; generate all possible sets consisting of k distinct elements taken from S.\n; The number of k-combinations for a sequence is equal to the binomial coefficient.\n\n(= (__ 1 #{4 5 6}) #{#{4} #{5} #{6}})\n\n\t\n(= (__ 10 #{4 5 6}) #{})\n\n\t\n(= (__ 2 #{0 1 2}) #{#{0 1} #{0 2} #{1 2}})\n\n\t\n(= (__ 3 #{0 1 2 3 4}) #{#{0 1 2} #{0 1 3} #{0 1 4} #{0 2 3} #{0 2 4}\n                         #{0 3 4} #{1 2 3} #{1 2 4} #{1 3 4} #{2 3 4}})\n\n\t\n(= (__ 4 #{[1 2 3] :a \"abc\" \"efg\"}) #{#{[1 2 3] :a \"abc\" \"efg\"}})\n\n\t\n(= (__ 2 #{[1 2 3] :a \"abc\" \"efg\"}) #{#{[1 2 3] :a} #{[1 2 3] \"abc\"} #{[1 2 3] \"efg\"}\n                                    #{:a \"abc\"} #{:a \"efg\"} #{\"abc\" \"efg\"}})```"}]}],"title":"4clojure - Problem 103"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"r9LpHBi5fCR","children":[{"edit-time:":1614171257616,"uid":"87rrShwAl8W","string":"**URL:** https://www.4clojure.com/problem/104"},{"edit-time:":1614171257616,"uid":"7Z5P5oG8OpP","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"fSZtm_3Mgbw","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"pj1agRsbsP9","string":"Topics: strings math"}]},{"edit-time:":1614171257616,"uid":"Ipu4B8Is6zN","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"QmgtMWB_xTx","string":"```clojure\n; This is the inverse of Problem 92, but much easier.\n; Given an integer smaller than 4000, return the corresponding roman numeral in uppercase, adhering to the subtractive principle.\n\n(= \"I\" (__ 1))\n\n\t\n(= \"XXX\" (__ 30))\n\n\t\n(= \"IV\" (__ 4))\n\n\t\n(= \"CXL\" (__ 140))\n\n\t\n(= \"DCCCXXVII\" (__ 827))\n\n\t\n(= \"MMMCMXCIX\" (__ 3999))\n\n\t\n(= \"XLVIII\" (__ 48))```"}]}],"title":"4clojure - Problem 104"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"cVeq0UMhtzb","children":[{"edit-time:":1614171257616,"uid":"VbXHn4WEUom","string":"**URL:** https://www.4clojure.com/problem/105"},{"edit-time:":1614171257616,"uid":"JnEs8RDq5Y3","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"DxWFE7dbxIw","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"PDSFOQlySMo","string":"Topics: maps seqs"}]},{"edit-time:":1614171257616,"uid":"C-5SX3TVZq0","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"lRpfNnnQEKT","string":"```clojure\n; Given an input sequence of keywords and numbers, create a map such that each key in the map is a keyword, and the value is a sequence of all the numbers (if any) between it and the next keyword in the sequence.\n\n(= {} (__ []))\n\n\t\n(= {:a [1]} (__ [:a 1]))\n\n\t\n(= {:a [1], :b [2]} (__ [:a 1, :b 2]))\n\n\t\n(= {:a [1 2 3], :b [], :c [4]} (__ [:a 1 2 3 :b :c 4]))```"}]}],"title":"4clojure - Problem 105"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"hKXCTkIpjNM","children":[{"edit-time:":1614171257616,"uid":"1exHs_muhBV","string":"**URL:** https://www.4clojure.com/problem/106"},{"edit-time:":1614171257616,"uid":"YpetqTsBixI","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"KczbBmWWS68","string":"Difficulty: Hard"},{"edit-time:":1614171257616,"uid":"0_5d6QefmUT","string":"Topics: numbers"}]},{"edit-time:":1614171257616,"uid":"hj8Rz8aCpNw","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"nkO4HUTQdR6","string":"```clojure\n; Given a pair of numbers, the start and end point, find a path between the two using only three possible operations:\n; double\n; halve (odd numbers cannot be halved)\n; add 2\n; Find the shortest path through the \"maze\".\n; Because there are multiple shortest paths, you must return the length of the shortest path, not the path itself.\n\n(= 1 (__ 1 1))  ; 1\n\n\t\n(= 3 (__ 3 12)) ; 3 6 12\n\n\t\n(= 3 (__ 12 3)) ; 12 6 3\n\n\t\n(= 3 (__ 5 9))  ; 5 7 9\n\n\t\n(= 9 (__ 9 2))  ; 9 18 20 10 12 6 8 4 2\n\n\t\n(= 5 (__ 9 12)) ; 9 11 22 24 12```"}]}],"title":"4clojure - Problem 106"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"QZ6t4BxhE3p","children":[{"edit-time:":1614171257616,"uid":"kj_e0BXbo8A","string":"**URL:** https://www.4clojure.com/problem/107"},{"edit-time:":1614171257616,"uid":"j63Io28Va75","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"q-zHpGF_-Iy","string":"Difficulty: Easy"},{"edit-time:":1614171257616,"uid":"MiDVRbWeUIx","string":"Topics: higher-order-functions math"}]},{"edit-time:":1614171257616,"uid":"LcDoUuS0XwS","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"7iUrTfz9ghP","string":"```clojure\n; Lexical scope and first-class functions are two of the most basic building blocks of a functional language like Clojure.\n; When you combine the two together, you get something very powerful called lexical closures.\n; With these, you can exercise a great deal of control over the lifetime of your local bindings, saving their values for use later, long after the code you're running now has finished.\n; \n; \n; It can be hard to follow in the abstract, so let's build a simple closure.\n; Given a positive integer n, return a function (f x) which computes xn.\n; Observe that the effect of this is to preserve the value of n for use outside the scope in which it is defined.\n\n(= 256 ((__ 2) 16),\n       ((__ 8) 2))\n\n\t\n(= [1 8 27 64] (map (__ 3) [1 2 3 4]))\n\n\t\n(= [1 2 4 8 16] (map #((__ %) 2) [0 1 2 3 4]))```"}]}],"title":"4clojure - Problem 107"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"VCZSp2W05Hi","children":[{"edit-time:":1614171257616,"uid":"vrBCMWFJyM5","string":"**URL:** https://www.4clojure.com/problem/108"},{"edit-time:":1614171257616,"uid":"tHZJcvMYWsH","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"sEE2YX5tm2G","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"78Y7r1YN5o5","string":"Topics: seqs sorting"}]},{"edit-time:":1614171257616,"uid":"BCynqWNVJnL","string":"**Syntax**:","children":[{"edit-time:":1614171257616,"uid":"OzmJCo-r6Pe","string":"```clojure\n(bit-and ...)```"}]},{"edit-time:":1614171257616,"uid":"vW0X5co79d4","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"95HDNKOqrw0","string":"```clojure\n; Given any number of sequences, each sorted from smallest to largest, find the smallest single number which appears in all of the sequences.\n; The sequences may be infinite, so be careful to search lazily.\n\n(= 3 (__ [3 4 5]))\n\n\t\n(= 4 (__ [1 2 3 4 5 6 7] [0.5 3/2 4 19]))\n\n\t\n(= 7 (__ (range) (range 0 100 7/6) [2 3 5 7 11 13]))\n\n\t\n(= 64 (__ (map #(* % % %) (range)) ;; perfect cubes\n          (filter #(zero? (bit-and % (dec %))) (range)) ;; powers of 2\n          (iterate inc 20))) ;; at least as large as 20```"}]}],"title":"4clojure - Problem 108"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"8A03ovriYgZ","children":[{"edit-time:":1614171257616,"uid":"G0PqQEaLLNJ","string":"**URL:** https://www.4clojure.com/problem/110"},{"edit-time:":1614171257616,"uid":"4q5PJ-xOYQL","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"9CCJG8RzNf0","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"yPF6sNHB-b8","string":"Topics: seqs"}]},{"edit-time:":1614171257616,"uid":"em141mu93sX","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"okECrzqUFPG","string":"```clojure\n; Write a function that returns a lazy sequence of \"pronunciations\" of a sequence of numbers.\n; A pronunciation of each element in the sequence consists of the number of repeating identical numbers and the number itself.\n; For example, [1 1] is pronounced as [2 1] (\"two ones\"), which in turn is pronounced as [1 2 1 1] (\"one two, one one\").\n; \n; \n; Your function should accept an initial sequence of numbers, and return an infinite lazy sequence of pronunciations, each element being a pronunciation of the previous element.\n\n(= [[1 1] [2 1] [1 2 1 1]] (take 3 (__ [1])))\n\n\t\n(= [3 1 2 4] (first (__ [1 1 1 4 4])))\n\n\t\n(= [1 1 1 3 2 1 3 2 1 1] (nth (__ [1]) 6))\n\n\t\n(= 338 (count (nth (__ [3 2]) 15)))```"}]}],"title":"4clojure - Problem 110"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"3YbwiQ3pSQa","children":[{"edit-time:":1614171257616,"uid":"Um-3Tpy2jun","string":"**URL:** https://www.4clojure.com/problem/111"},{"edit-time:":1614171257616,"uid":"hmLBGW1fWLs","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"b-g6mjL8E-A","string":"Difficulty: Hard"},{"edit-time:":1614171257616,"uid":"4w-l5g1IELB","string":"Topics: game"}]},{"edit-time:":1614171257616,"uid":"YZFBN12H_ud","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"gxQDhnfzoOQ","string":"```clojure\n; Write a function that takes a string and a partially-filled crossword puzzle board, and determines if the input string can be legally placed onto the board.\n; \n; The crossword puzzle board consists of a collection of partially-filled rows.\n; Empty spaces are denoted with an underscore (_), unusable spaces are denoted with a hash symbol (#), and pre-filled spaces have a character in place; the whitespace characters are for legibility and should be ignored.\n; \n; \n; For a word to be legally placed on the board:\n; - It may use empty spaces (underscores)\n; - It may use but must not conflict with any pre-filled characters.\n; - It must not use any unusable spaces (hashes).\n; - There must be no empty spaces (underscores) or extra characters before or after the word (the word may be bound by unusable spaces though).\n; - Characters are not case-sensitive.\n; - Words may be placed vertically (proceeding top-down only), or horizontally (proceeding left-right only).\n\n(= true  (__ \"the\" [\"_ # _ _ e\"]))\n\n\t\n(= false (__ \"the\" [\"c _ _ _\"\n                    \"d _ # e\"\n                    \"r y _ _\"]))\n\n\t\n(= true  (__ \"joy\" [\"c _ _ _\"\n                    \"d _ # e\"\n                    \"r y _ _\"]))\n\n\t\n(= false (__ \"joy\" [\"c o n j\"\n                    \"_ _ y _\"\n                    \"r _ _ #\"]))\n\n\t\n(= true  (__ \"clojure\" [\"_ _ _ # j o y\"\n                        \"_ _ o _ _ _ _\"\n                        \"_ _ f _ # _ _\"]))```"}]}],"title":"4clojure - Problem 111"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"aKNR9d7RNyU","children":[{"edit-time:":1614171257616,"uid":"NrUaDm_J7DS","string":"**URL:** https://www.4clojure.com/problem/112"},{"edit-time:":1614171257616,"uid":"Ju7ibonMtPW","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"FTUBfb4Nz5k","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"r4MZIuhxDVF","string":"Topics: seqs"}]},{"edit-time:":1614171257616,"uid":"nsIz4xUWW9z","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"LDtKq4iIgkL","string":"```clojure\n; Create a function which takes an integer and a nested collection of integers as arguments.\n; Analyze the elements of the input collection and return a sequence which maintains the nested structure, and which includes all elements starting from the head whose sum is less than or equal to the input integer.\n\n(=  (__ 10 [1 2 [3 [4 5] 6] 7])\n   '(1 2 (3 (4))))\n\n\t\n(=  (__ 30 [1 2 [3 [4 [5 [6 [7 8]] 9]] 10] 11])\n   '(1 2 (3 (4 (5 (6 (7)))))))\n\n\t\n(=  (__ 9 (range))\n   '(0 1 2 3))\n\n\t\n(=  (__ 1 [[[[[1]]]]])\n   '(((((1))))))\n\n\t\n(=  (__ 0 [1 2 [3 [4 5] 6] 7])\n   '())\n\n\t\n(=  (__ 0 [0 0 [0 [0]]])\n   '(0 0 (0 (0))))\n\n\t\n(=  (__ 1 [-10 [1 [2 3 [4 5 [6 7 [8]]]]]])\n   '(-10 (1 (2 3 (4)))))```"}]}],"title":"4clojure - Problem 112"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"m-2h30OA93G","children":[{"edit-time:":1614171257616,"uid":"9pOPu5_sp95","string":"**URL:** https://www.4clojure.com/problem/113"},{"edit-time:":1614171257616,"uid":"fqqUeKY7qiF","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"6lXFQa4tHAO","string":"Difficulty: Hard"},{"edit-time:":1614171257616,"uid":"LsEUkkzWEyb","string":"Topics: types"}]},{"edit-time:":1614171257616,"uid":"YiglQZlq61o","string":"**Syntax**:","children":[{"edit-time:":1614171257616,"uid":"RTaMbuUZkbz","string":"```clojure\n(seq ...)```"},{"edit-time:":1614171257616,"uid":"XPsygUN5Upp","string":"```clojure\n(repeat ...)```"}]},{"edit-time:":1614171257616,"uid":"Rbe8Hugtf85","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"zL1JxbmZhfq","string":"```clojure\n; Write a function that takes a variable number of integer arguments.\n; If the output is coerced into a string, it should return a comma (and space) separated list of the inputs sorted smallest to largest.\n; If the output is coerced into a sequence, it should return a seq of unique input elements in the same order as they were entered.\n\n; Special Restrictions:\n; proxy\n\n(= \"1, 2, 3\" (str (__ 2 1 3)))\n\n\t\n(= '(2 1 3) (seq (__ 2 1 3)))\n\n\t\n(= '(2 1 3) (seq (__ 2 1 3 3 1 2)))\n\n\t\n(= '(1) (seq (apply __ (repeat 5 1))))\n\n\t\n(= \"1, 1, 1, 1, 1\" (str (apply __ (repeat 5 1))))\n\n\t\n(and (= nil (seq (__)))\n     (=  \"\" (str (__))))```"}]}],"title":"4clojure - Problem 113"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"E8Ib5cJQzZW","children":[{"edit-time:":1614171257616,"uid":"dUynW2AnBLn","string":"**URL:** https://www.4clojure.com/problem/114"},{"edit-time:":1614171257616,"uid":"U7z6_iUUAtH","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"5-JQc5oBWy9","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"s2VyAd6OD4i","string":"Topics: seqs higher-order-functions"}]},{"edit-time:":1614171257616,"uid":"SvcIc-PS7BY","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"p3ABLZl5tYQ","string":"```clojure\n; take-while is great for filtering sequences, but it limited: you can only examine a single item of the sequence at a time.\n; What if you need to keep track of some state as you go over the sequence?.\n; \n; \n; Write a function which accepts an integer n, a predicate p, and a sequence.\n; It should return a lazy sequence of items in the list up to, but not including, the nth item that satisfies the predicate.\n\n(= [2 3 5 7 11 13]\n   (__ 4 #(= 2 (mod % 3))\n         [2 3 5 7 11 13 17 19 23]))\n\n\t\n(= [\"this\" \"is\" \"a\" \"sentence\"]\n   (__ 3 #(some #{\\i} %)\n         [\"this\" \"is\" \"a\" \"sentence\" \"i\" \"wrote\"]))\n\n\t\n(= [\"this\" \"is\"]\n   (__ 1 #{\"a\"}\n         [\"this\" \"is\" \"a\" \"sentence\" \"i\" \"wrote\"]))```"}]}],"title":"4clojure - Problem 114"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"bRdomEhUkrQ","children":[{"edit-time:":1614171257616,"uid":"irp_P7MddJm","string":"**URL:** https://www.4clojure.com/problem/115"},{"edit-time:":1614171257616,"uid":"d6ONUiyS0PH","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"V1sxSzTNgJV","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"IrgxM5GZj4w","string":"Topics: math"}]},{"edit-time:":1614171257616,"uid":"6Q93d6P6Plm","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"tRciBG83OGX","string":"```clojure\n; A balanced number is one whose component digits have the same sum on the left and right halves of the number.\n; Write a function which accepts an integer n, and returns true iff n is balanced.\n\n(= true (__ 11))\n\n\t\n(= true (__ 121))\n\n\t\n(= false (__ 123))\n\n\t\n(= true (__ 0))\n\n\t\n(= false (__ 88099))\n\n\t\n(= true (__ 89098))\n\n\t\n(= true (__ 89089))\n\n\t\n(= (take 20 (filter __ (range)))\n   [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101])```"}]}],"title":"4clojure - Problem 115"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"MYDgXgKYRUt","children":[{"edit-time:":1614171257616,"uid":"_5H6pmGt7zQ","string":"**URL:** https://www.4clojure.com/problem/116"},{"edit-time:":1614171257616,"uid":"rZxiHdNTGcp","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"Ke1R8NQNhId","string":"Difficulty: Medium"},{"edit-time:":1614171257616,"uid":"L3_AFpccbs5","string":"Topics: math"}]},{"edit-time:":1614171257616,"uid":"wtMn3OLuFOg","string":"**Problem:**","children":[{"edit-time:":1614171257616,"uid":"qMFnk1F8g-6","string":"```clojure\n; A balanced prime is a prime number which is also the mean of the primes directly before and after it in the sequence of valid primes.\n; Create a function which takes an integer n, and returns true iff it is a balanced prime.\n\n(= false (__ 4))\n\n\t\n(= true (__ 563))\n\n\t\n(= 1103 (nth (filter __ (range)) 15))```"}]}],"title":"4clojure - Problem 116"},{"create-time":1614171257616,"edit-time:":1614171257616,"uid":"6G0QjquIhjL","children":[{"edit-time:":1614171257616,"uid":"XhGPV7isLqX","string":"**URL:** https://www.4clojure.com/problem/117"},{"edit-time:":1614171257616,"uid":"Xr2PPAQWmaX","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257616,"uid":"ZfOmzd9hXWX","string":"Difficulty: Hard"},{"edit-time:":1614171257616,"uid":"X4sJSH6cWit","string":"Topics: game"}]},{"edit-time:":1614171257616,"uid":"EWcMMTEvwrO","string":"**Problem:**","children":[{"edit-time:":1614171257617,"uid":"FP_Db8H-uZA","string":"```clojure\n; A mad scientist with tenure has created an experiment tracking mice in a maze.\n; Several mazes have been randomly generated, and you've been tasked with writing a program to determine the mazes in which it's possible for the mouse to reach the cheesy endpoint.\n; Write a function which accepts a maze in the form of a collection of rows, each row is a string where:.\n; \n; spaces represent areas where the mouse can walk freely\n; hashes (#) represent walls where the mouse can not walk\n; M represents the mouse's starting point\n; C represents the cheese which the mouse must reach\n; The mouse is not allowed to travel diagonally in the maze (only up/down/left/right), nor can he escape the edge of the maze.\n; Your function must return true iff the maze is solvable by the mouse.\n\n(= true  (__ [\"M   C\"]))\n\n\t\n(= false (__ [\"M # C\"]))\n\n\t\n(= true  (__ [\"#######\"\n              \"#     #\"\n              \"#  #  #\"\n              \"#M # C#\"\n              \"#######\"]))\n\n\t\n(= false (__ [\"########\"\n              \"#M  #  #\"\n              \"#   #  #\"\n              \"# # #  #\"\n              \"#   #  #\"\n              \"#  #   #\"\n              \"#  # # #\"\n              \"#  #   #\"\n              \"#  #  C#\"\n              \"########\"]))\n\n\t\n(= false (__ [\"M     \"\n              \"      \"\n              \"      \"\n              \"      \"\n              \"    ##\"\n              \"    #C\"]))\n\n\t\n(= true  (__ [\"C######\"\n              \" #     \"\n              \" #   # \"\n              \" #   #M\"\n              \"     # \"]))\n\n\t\n(= true  (__ [\"C# # # #\"\n              \"        \"\n              \"# # # # \"\n              \"        \"\n              \" # # # #\"\n              \"        \"\n              \"# # # #M\"]))```"}]}],"title":"4clojure - Problem 117"},{"create-time":1614171257617,"edit-time:":1614171257617,"uid":"NjYJDj_eOX4","children":[{"edit-time:":1614171257617,"uid":"FKbUBTKFH3U","string":"**URL:** https://www.4clojure.com/problem/118"},{"edit-time:":1614171257617,"uid":"7ddD0ZEqMHl","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257617,"uid":"7dNnmOdxq76","string":"Difficulty: Easy"},{"edit-time:":1614171257617,"uid":"19wWdBCtBi1","string":"Topics: core-seqs"}]},{"edit-time:":1614171257617,"uid":"CP0i3hzCpCU","string":"**Problem:**","children":[{"edit-time:":1614171257617,"uid":"y_BqvBaZadn","string":"```clojure\n; Map is one of the core elements of a functional programming language.\n; Given a function f and an input sequence s, return a lazy sequence of (f x) for each element x in s.\n\n; Special Restrictions:\n; map\n; map-indexed\n; mapcat\n; for\n\n(= [3 4 5 6 7]\n   (__ inc [2 3 4 5 6]))\n\n\t\n(= (repeat 10 nil)\n   (__ (fn [_] nil) (range 10)))\n\n\t\n(= [1000000 1000001]\n   (->> (__ inc (range))\n        (drop (dec 1000000))\n        (take 2)))```"}]}],"title":"4clojure - Problem 118"},{"create-time":1614171257617,"edit-time:":1614171257617,"uid":"Tt17AKlXSWb","children":[{"edit-time:":1614171257617,"uid":"euuzt_gKCzW","string":"**URL:** https://www.4clojure.com/problem/119"},{"edit-time:":1614171257617,"uid":"MbmOpaygRmG","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257617,"uid":"U1p9pwHE_Fi","string":"Difficulty: Hard"},{"edit-time:":1614171257617,"uid":"Q3Nd3TLa7bq","string":"Topics: game"}]},{"edit-time:":1614171257617,"uid":"1G5AZFr2_sC","string":"**Problem:**","children":[{"edit-time:":1614171257617,"uid":"m-wSw6M_T-X","string":"```clojure\n; As in Problem 73, a tic-tac-toe board is represented by a two dimensional vector.\n; X is represented by :x, O is represented by :o, and empty is represented by :e.\n; Create a function that accepts a game piece and board as arguments, and returns a set (possibly empty) of all valid board placements of the game piece which would result in an immediate win.\n; \n; \n; Board coordinates should be as in calls to get-in.\n; For example, [0 1] is the topmost row, center position.\n\n(= (__ :x [[:o :e :e] \n           [:o :x :o] \n           [:x :x :e]])\n   #{[2 2] [0 1] [0 2]})\n\n\t\n(= (__ :x [[:x :o :o] \n           [:x :x :e] \n           [:e :o :e]])\n   #{[2 2] [1 2] [2 0]})\n\n\t\n(= (__ :x [[:x :e :x] \n           [:o :x :o] \n           [:e :o :e]])\n   #{[2 2] [0 1] [2 0]})\n\n\t\n(= (__ :x [[:x :x :o] \n           [:e :e :e] \n           [:e :e :e]])\n   #{})\n\n\t\n(= (__ :o [[:x :x :o] \n           [:o :e :o] \n           [:x :e :e]])\n   #{[2 2] [1 1]})```"}]}],"title":"4clojure - Problem 119"},{"create-time":1614171257617,"edit-time:":1614171257617,"uid":"y7jBDaC6iiE","children":[{"edit-time:":1614171257617,"uid":"8DkGRfSk0nn","string":"**URL:** https://www.4clojure.com/problem/120"},{"edit-time:":1614171257617,"uid":"3ycXvGKKl9p","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257617,"uid":"4J7JwcymRCa","string":"Difficulty: Easy"},{"edit-time:":1614171257617,"uid":"QWKoT-eCsdf","string":"Topics: math"}]},{"edit-time:":1614171257617,"uid":"--waA13eaS3","string":"**Problem:**","children":[{"edit-time:":1614171257617,"uid":"tieP0ao25kB","string":"```clojure\n; Write a function which takes a collection of integers as an argument.\n; Return the count of how many elements are smaller than the sum of their squared component digits.\n; For example: 10 is larger than 1 squared plus 0 squared; whereas 15 is smaller than 1 squared plus 5 squared.\n\n(= 8 (__ (range 10)))\n\n\t\n(= 19 (__ (range 30)))\n\n\t\n(= 50 (__ (range 100)))\n\n\t\n(= 50 (__ (range 1000)))```"}]}],"title":"4clojure - Problem 120"},{"create-time":1614171257617,"edit-time:":1614171257617,"uid":"GywWTLp0NUe","children":[{"edit-time:":1614171257617,"uid":"3yVZZFXBSjV","string":"**URL:** https://www.4clojure.com/problem/121"},{"edit-time:":1614171257617,"uid":"MSmdFWcGiZd","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257617,"uid":"FN_IP7RqPL2","string":"Difficulty: Medium"},{"edit-time:":1614171257617,"uid":"T9HnmJxhVMU","string":"Topics: functions"}]},{"edit-time:":1614171257617,"uid":"EE0b1pJP9vN","string":"**Problem:**","children":[{"edit-time:":1614171257617,"uid":"OBJqA8oDMVv","string":"```clojure\n; Given a mathematical formula in prefix notation, return a function that calculates the value of the formula.\n; The formula can contain nested calculations using the four basic mathematical operators, numeric constants, and symbols representing variables.\n; The returned function has to accept a single parameter containing the map of variable names to their values.\n\n; Special Restrictions:\n; eval\n; resolve\n\n(= 2 ((__ '(/ a b))\n      '{b 8 a 16}))\n\n\t\n(= 8 ((__ '(+ a b 2))\n      '{a 2 b 4}))\n\n\t\n(= [6 0 -4]\n     (map (__ '(* (+ 2 a)\n                  (- 10 b)))\n            '[{a 1 b 8}\n              {b 5 a -2}\n              {a 2 b 11}]))\n\n\t\n(= 1 ((__ '(/ (+ x 2)\n              (* 3 (+ y 1))))\n      '{x 4 y 1}))```"}]}],"title":"4clojure - Problem 121"},{"create-time":1614171257617,"edit-time:":1614171257617,"uid":"YGJLRtmVV5t","children":[{"edit-time:":1614171257617,"uid":"CUpEEUTza5a","string":"**URL:** https://www.4clojure.com/problem/122"},{"edit-time:":1614171257617,"uid":"jASfBBst0fq","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257617,"uid":"UaCLpr9LKe4","string":"Difficulty: Easy"}]},{"edit-time:":1614171257617,"uid":"bqII5_k3SOR","string":"**Problem:**","children":[{"edit-time:":1614171257617,"uid":"Z9arA9rEHmF","string":"```clojure\n; Convert a binary number, provided in the form of a string, to its numerical value.\n\n(= 0     (__ \"0\"))\n\n\t\n(= 7     (__ \"111\"))\n\n\t\n(= 8     (__ \"1000\"))\n\n\t\n(= 9     (__ \"1001\"))\n\n\t\n(= 255   (__ \"11111111\"))\n\n\t\n(= 1365  (__ \"10101010101\"))\n\n\t\n(= 65535 (__ \"1111111111111111\"))```"}]}],"title":"4clojure - Problem 122"},{"create-time":1614171257617,"edit-time:":1614171257617,"uid":"5XkpVr83Aan","children":[{"edit-time:":1614171257617,"uid":"TMxYerlF7kh","string":"**URL:** https://www.4clojure.com/problem/124"},{"edit-time:":1614171257617,"uid":"EVundXAo0EV","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257617,"uid":"qR-47HbdtY1","string":"Difficulty: Hard"},{"edit-time:":1614171257617,"uid":"fAAo52RKtvB","string":"Topics: game"}]},{"edit-time:":1614171257617,"uid":"sbz8bL6Hodd","string":"**Problem:**","children":[{"edit-time:":1614171257617,"uid":"Hei7mKy97RM","string":"```clojure\n; Reversi is normally played on an 8 by 8 board.\n; In this problem, a 4 by 4 board is represented as a two-dimensional vector with black, white, and empty pieces represented by 'b, 'w, and 'e, respectively.\n; Create a function that accepts a game board and color as arguments, and returns a map of legal moves for that color.\n; Each key should be the coordinates of a legal move, and its value a set of the coordinates of the pieces flipped by that move.\n; \n; \n; Board coordinates should be as in calls to get-in.\n; For example, [0 1] is the topmost row, second column from the left.\n\n(= {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}}\n   (__ '[[e e e e]\n         [e w b e]\n         [e b w e]\n         [e e e e]] 'w))\n\n\t\n(= {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}}\n   (__ '[[e e e e]\n         [e w b e]\n         [w w w e]\n         [e e e e]] 'b))\n\n\t\n(= {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}\n   (__ '[[e e e e]\n         [e w b e]\n         [w w b e]\n         [e e b e]] 'w))\n\n\t\n(= {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 1] [2 2]}}\n   (__ '[[e e w e]\n         [b b w e]\n         [b w w e]\n         [b w w w]] 'b))```"}]}],"title":"4clojure - Problem 124"},{"create-time":1614171257617,"edit-time:":1614171257617,"uid":"tS3uwDCg1G1","children":[{"edit-time:":1614171257617,"uid":"y00ZKUIh3mw","string":"**URL:** https://www.4clojure.com/problem/125"},{"edit-time:":1614171257617,"uid":"OyaHam6YlY2","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257617,"uid":"EK79wExPFHH","string":"Difficulty: Hard"},{"edit-time:":1614171257617,"uid":"0CPVV66MFPA","string":"Topics: logic fun brain-teaser"}]},{"edit-time:":1614171257617,"uid":"iK107G1pgmI","string":"**Problem:**","children":[{"edit-time:":1614171257617,"uid":"6VZZ1gTzQWj","string":"```clojure\n; Create a function of no arguments which returns a string that is an exact copy of the function itself.\n; \n; Hint: read this if you get stuck (this question is harder than it first appears); but it's worth the effort to solve it independently if you can!\n; \n; Fun fact: Gus is the name of the 4Clojure dragon.\n\n(= (str '__) (__))```"}]}],"title":"4clojure - Problem 125"},{"create-time":1614171257617,"edit-time:":1614171257617,"uid":"xKjoaKdHTdG","children":[{"edit-time:":1614171257617,"uid":"0HS8g63mDSX","string":"**URL:** https://www.4clojure.com/problem/126"},{"edit-time:":1614171257617,"uid":"cGuv56Vmc2n","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257617,"uid":"P6e8hBBA2Um","string":"Difficulty: Easy"},{"edit-time:":1614171257617,"uid":"3anCrf0sgZ1","string":"Topics: fun brain-teaser"}]},{"edit-time:":1614171257617,"uid":"U867NxbWq3v","string":"**Syntax**:","children":[{"edit-time:":1614171257617,"uid":"-Tzm4Rq81Rg","string":"```clojure\n(class ...)```"}]},{"edit-time:":1614171257617,"uid":"m3kp17sLl4g","string":"**Problem:**","children":[{"edit-time:":1614171257618,"uid":"8Hvl_KdJ1VF","string":"```clojure\n; Enter a value which satisfies the following:\n\n(let [x __]\n  (and (= (class x) x) x))```"}]}],"title":"4clojure - Problem 126"},{"create-time":1614171257618,"edit-time:":1614171257618,"uid":"m85Yp50_T55","children":[{"edit-time:":1614171257618,"uid":"ChSqcz1gpkA","string":"**URL:** https://www.4clojure.com/problem/127"},{"edit-time:":1614171257618,"uid":"ej2Qqjve99F","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257618,"uid":"CSeN6RzonPm","string":"Difficulty: Hard"},{"edit-time:":1614171257618,"uid":"-m6BAjzTnlD","string":"Topics: search data-juggling"}]},{"edit-time:":1614171257618,"uid":"mS5jk-F08BI","string":"**Problem:**","children":[{"edit-time:":1614171257619,"uid":"hznSbDoi-uR","string":"```clojure\n; Everyone loves triangles, and it's easy to understand why—they're so wonderfully symmetric (except scalenes, they suck).\n; \n; Your passion for triangles has led you to become a miner (and part-time Clojure programmer) where you work all day to chip out isosceles-shaped minerals from rocks gathered in a nearby open-pit mine.\n; There are too many rocks coming from the mine to harvest them all so you've been tasked with writing a program to analyze the mineral patterns of each rock, and determine which rocks have the biggest minerals.\n; \n; \n; Someone has already written a computer-vision system for the mine.\n; It images each rock as it comes into the processing centre and creates a cross-sectional bitmap of mineral (1) and rock (0) concentrations for each one.\n; \n; \n; You must now create a function which accepts a collection of integers, each integer when read in base-2 gives the bit-representation of the rock (again, 1s are mineral and 0s are worthless scalene-like rock).\n; You must return the cross-sectional area of the largest harvestable mineral from the input rock, as follows:.\n; \n; \n; The minerals only have smooth faces when sheared vertically or horizontally from the rock's cross-section\n; The mine is only concerned with harvesting isosceles triangles (such that one or two sides can be sheared)\n; If only one face of the mineral is sheared, its opposing vertex must be a point (ie.\n; the smooth face must be of odd length), and its two equal-length sides must intersect the shear face at 45° (ie.\n; those sides must cut even-diagonally).\n; \n; The harvested mineral may not contain any traces of rock\n; The mineral may lie in any orientation in the plane\n; Area should be calculated as the sum of 1s that comprise the mineral\n; Minerals must have a minimum of three measures of area to be harvested\n; If no minerals can be harvested from the rock, your function should return nil\n\n(= 10 (__ [15 15 15 15 15]))\n; 1111      1111\n; 1111      *111\n; 1111  ->  **11\n; 1111      ***1\n; 1111      ****\n\n\t\n(= 15 (__ [1 3 7 15 31]))\n; 00001      0000*\n; 00011      000**\n; 00111  ->  00***\n; 01111      0****\n; 11111      *****\n\n\t\n(= 3 (__ [3 3]))\n; 11      *1\n; 11  ->  **\n\n\t\n(= 4 (__ [7 3]))\n; 111      ***\n; 011  ->  0*1\n\n\t\n(= 6 (__ [17 22 6 14 22]))\n; 10001      10001\n; 10110      101*0\n; 00110  ->  00**0\n; 01110      0***0\n; 10110      10110\n\n\t\n(= 9 (__ [18 7 14 14 6 3]))\n; 10010      10010\n; 00111      001*0\n; 01110      01**0\n; 01110  ->  0***0\n; 00110      00**0\n; 00011      000*1\n\n\t\n(= nil (__ [21 10 21 10]))\n; 10101      10101\n; 01010      01010\n; 10101  ->  10101\n; 01010      01010\n\n\t\n(= nil (__ [0 31 0 31 0]))\n; 00000      00000\n; 11111      11111\n; 00000  ->  00000\n; 11111      11111\n; 00000      00000```"}]}],"title":"4clojure - Problem 127"},{"create-time":1614171257619,"edit-time:":1614171257619,"uid":"eWGOau3amFW","children":[{"edit-time:":1614171257619,"uid":"cbgY3VJMnCK","string":"**URL:** https://www.4clojure.com/problem/128"},{"edit-time:":1614171257619,"uid":"4EBVXEiiw3k","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257619,"uid":"JwUBwrg1pwJ","string":"Difficulty: Easy"},{"edit-time:":1614171257619,"uid":"sx_SFQcIt6l","string":"Topics: strings game"}]},{"edit-time:":1614171257619,"uid":"N6qixZkycZN","string":"**Syntax**:","children":[{"edit-time:":1614171257619,"uid":"VzWEVvYHeij","string":"```clojure\n(comp ...)```"}]},{"edit-time:":1614171257619,"uid":"oBRQVz3S7Ai","string":"**Problem:**","children":[{"edit-time:":1614171257619,"uid":"69eUhq0exrb","string":"```clojure\n; A standard American deck of playing cards has four suits - spades, hearts, diamonds, and clubs - and thirteen cards in each suit.\n; Two is the lowest rank, followed by other integers up to ten; then the jack, queen, king, and ace.\n; \n; \n; It's convenient for humans to represent these cards as suit/rank pairs, such as H5 or DQ: the heart five and diamond queen respectively.\n; But these forms are not convenient for programmers, so to write a card game you need some way to parse an input string into meaningful components.\n; For purposes of determining rank, we will define the cards to be valued from 0 (the two) to 12 (the ace).\n; \n; \n; Write a function which converts (for example) the string \"SJ\" into a map of {:suit :spade, :rank 9}.\n; A ten will always be represented with the single character \"T\", rather than the two characters \"10\".\n\n(= {:suit :diamond :rank 10} (__ \"DQ\"))\n\n\t\n(= {:suit :heart :rank 3} (__ \"H5\"))\n\n\t\n(= {:suit :club :rank 12} (__ \"CA\"))\n\n\t\n(= (range 13) (map (comp :rank __ str)\n                   '[S2 S3 S4 S5 S6 S7\n                     S8 S9 ST SJ SQ SK SA]))```"}]}],"title":"4clojure - Problem 128"},{"create-time":1614171257619,"edit-time:":1614171257619,"uid":"NHAZYAx0dJe","children":[{"edit-time:":1614171257619,"uid":"QgVlEnbtAXG","string":"**URL:** https://www.4clojure.com/problem/130"},{"edit-time:":1614171257619,"uid":"25yvoHYTo5-","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257619,"uid":"6fHFdh2olKf","string":"Difficulty: Hard"},{"edit-time:":1614171257619,"uid":"qafMNIoTm-n","string":"Topics: tree"}]},{"edit-time:":1614171257619,"uid":"SptwDc0ufDA","string":"**Problem:**","children":[{"edit-time:":1614171257619,"uid":"X8ZhACGqBlC","string":"```clojure\n; Every node of a tree is connected to each of its children as well as its parent.\n; One can imagine grabbing one node of a tree and dragging it up to the root position, leaving all connections intact.\n; For example, below on the left is a binary tree.\n; By pulling the \"c\" node up to the root, we obtain the tree on the right.\n; \n; \n; Note it is no longer binary as \"c\" had three connections total -- two children and one parent.\n; Each node is represented as a vector, which always has at least one element giving the name of the node as a symbol.\n; Subsequent items in the vector represent the children of the node.\n; Because the children are ordered it's important that the tree you return keeps the children of each node in order and that the old parent node, if any, is appended on the right.\n; Your function will be given two args -- the name of the node that should become the new root, and the tree to transform.\n\n(= '(n)\n   (__ 'n '(n)))\n\n\t\n(= '(a (t (e)))\n   (__ 'a '(t (e) (a))))\n\n\t\n(= '(e (t (a)))\n   (__ 'e '(a (t (e)))))\n\n\t\n(= '(a (b (c)))\n   (__ 'a '(c (b (a)))))\n\n\t\n(= '(d \n      (b\n        (c)\n        (e)\n        (a \n          (f \n            (g) \n            (h)))))\n  (__ 'd '(a\n            (b \n              (c) \n              (d) \n              (e))\n            (f \n              (g)\n              (h)))))\n\n\t\n(= '(c \n      (d) \n      (e) \n      (b\n        (f \n          (g) \n          (h))\n        (a\n          (i\n          (j\n            (k)\n            (l))\n          (m\n            (n)\n            (o))))))\n   (__ 'c '(a\n             (b\n               (c\n                 (d)\n                 (e))\n               (f\n                 (g)\n                 (h)))\n             (i\n               (j\n                 (k)\n                 (l))\n               (m\n                 (n)\n                 (o))))))```"}]}],"title":"4clojure - Problem 130"},{"create-time":1614171257619,"edit-time:":1614171257619,"uid":"ktw8NM8-RCx","children":[{"edit-time:":1614171257619,"uid":"K0_aWFulfQS","string":"**URL:** https://www.4clojure.com/problem/131"},{"edit-time:":1614171257619,"uid":"j2KWGH7d9aQ","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257619,"uid":"d88BkGLvH3i","string":"Difficulty: Medium"},{"edit-time:":1614171257619,"uid":"qgtX64B5B_B","string":"Topics: math"}]},{"edit-time:":1614171257619,"uid":"25a35GguOcV","string":"**Problem:**","children":[{"edit-time:":1614171257619,"uid":"HPOES9XIjc3","string":"```clojure\n; Given a variable number of sets of integers, create a function which returns true iff all of the sets have a non-empty subset with an equivalent summation.\n\n(= true  (__ #{-1 1 99} \n             #{-2 2 888}\n             #{-3 3 7777})) ; ex. all sets have a subset which sums to zero\n\n\t\n(= false (__ #{1}\n             #{2}\n             #{3}\n             #{4}))\n\n\t\n(= true  (__ #{1}))\n\n\t\n(= false (__ #{1 -3 51 9} \n             #{0} \n             #{9 2 81 33}))\n\n\t\n(= true  (__ #{1 3 5}\n             #{9 11 4}\n             #{-3 12 3}\n             #{-3 4 -2 10}))\n\n\t\n(= false (__ #{-1 -2 -3 -4 -5 -6}\n             #{1 2 3 4 5 6 7 8 9}))\n\n\t\n(= true  (__ #{1 3 5 7}\n             #{2 4 6 8}))\n\n\t\n(= true  (__ #{-1 3 -5 7 -9 11 -13 15}\n             #{1 -3 5 -7 9 -11 13 -15}\n             #{1 -1 2 -2 4 -4 8 -8}))\n\n\t\n(= true  (__ #{-10 9 -8 7 -6 5 -4 3 -2 1}\n             #{10 -9 8 -7 6 -5 4 -3 2 -1}))```"}]}],"title":"4clojure - Problem 131"},{"create-time":1614171257619,"edit-time:":1614171257619,"uid":"yVjSyA_Xhic","children":[{"edit-time:":1614171257619,"uid":"m3mv6EftxUG","string":"**URL:** https://www.4clojure.com/problem/132"},{"edit-time:":1614171257619,"uid":"HQEGhnAEPpj","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257619,"uid":"gnq6tvKSGZA","string":"Difficulty: Medium"},{"edit-time:":1614171257619,"uid":"z6t7xeSv7Wa","string":"Topics: seqs core-functions"}]},{"edit-time:":1614171257619,"uid":"xHvLsYD6MoJ","string":"**Syntax**:","children":[{"edit-time:":1614171257619,"uid":"mqxm9An7ij9","string":"```clojure\n(< ...)```"}]},{"edit-time:":1614171257619,"uid":"I_eM6c37KHN","string":"**Problem:**","children":[{"edit-time:":1614171257619,"uid":"HWNIEP_G-kW","string":"```clojure\n; Write a function that takes a two-argument predicate, a value, and a collection; and returns a new collection where the value is inserted between every two items that satisfy the predicate.\n\n(= '(1 :less 6 :less 7 4 3) (__ < :less [1 6 7 4 3]))\n\n\t\n(= '(2) (__ > :more [2]))\n\n\t\n(= [0 1 :x 2 :x 3 :x 4]  (__ #(and (pos? %) (< % %2)) :x (range 5)))\n\n\t\n(empty? (__ > :more ()))\n\n\t\n(= [0 1 :same 1 2 3 :same 5 8 13 :same 21]\n   (take 12 (->> [0 1]\n                 (iterate (fn [[a b]] [b (+ a b)]))\n                 (map first) ; fibonacci numbers\n                 (__ (fn [a b] ; both even or both odd\n                       (= (mod a 2) (mod b 2)))\n                     :same))))```"}]}],"title":"4clojure - Problem 132"},{"create-time":1614171257619,"edit-time:":1614171257619,"uid":"lUManzqvT9R","children":[{"edit-time:":1614171257619,"uid":"MHL_1oP4-On","string":"**URL:** https://www.4clojure.com/problem/134"},{"edit-time:":1614171257619,"uid":"d83kOlOiW8M","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257619,"uid":"wjNnnGhQBtK","string":"Difficulty: Elementary"},{"edit-time:":1614171257619,"uid":"ihWSMbJJsOT","string":"Topics: maps"}]},{"edit-time:":1614171257619,"uid":"plKKnPsD1i_","string":"**Problem:**","children":[{"edit-time:":1614171257619,"uid":"vNH0JXjwqPX","string":"```clojure\n; Write a function which, given a key and map, returns true iff the map contains an entry with that key and its value is nil.\n\n(true?  (__ :a {:a nil :b 2}))\n\n\t\n(false? (__ :b {:a nil :b 2}))\n\n\t\n(false? (__ :c {:a nil :b 2}))```"}]}],"title":"4clojure - Problem 134"},{"create-time":1614171257619,"edit-time:":1614171257619,"uid":"4G1XwWt_J-U","children":[{"edit-time:":1614171257619,"uid":"qiRdznWMw2e","string":"**URL:** https://www.4clojure.com/problem/135"},{"edit-time:":1614171257619,"uid":"SXQ5RmqIdmy","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257619,"uid":"Vw1eqiLs5MM","string":"Difficulty: Easy"},{"edit-time:":1614171257619,"uid":"NWC4c58t3Oi","string":"Topics: higher-order-functions math"}]},{"edit-time:":1614171257619,"uid":"GOSkzcijdBa","string":"**Problem:**","children":[{"edit-time:":1614171257619,"uid":"0SM06Eat8VX","string":"```clojure\n; Your friend Joe is always whining about Lisps using the prefix notation for math.\n; Show him how you could easily write a function that does math using the infix notation.\n; Is your favorite language that flexible, Joe? Write a function that accepts a variable length mathematical expression consisting of numbers and the operations +, -, *, and /.\n; Assume a simple calculator that does not do precedence and instead just calculates left to right.\n\n(= 7  (__ 2 + 5))\n\n\t\n(= 42 (__ 38 + 48 - 2 / 2))\n\n\t\n(= 8  (__ 10 / 2 - 1 * 2))\n\n\t\n(= 72 (__ 20 / 2 + 2 + 4 + 8 - 6 - 10 * 9))```"}]}],"title":"4clojure - Problem 135"},{"create-time":1614171257619,"edit-time:":1614171257619,"uid":"-m_UuOYWSqo","children":[{"edit-time:":1614171257619,"uid":"1qE-Gq2RxPs","string":"**URL:** https://www.4clojure.com/problem/137"},{"edit-time:":1614171257619,"uid":"R4x_-aKqxnM","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257619,"uid":"-gVeXTN4S5Y","string":"Difficulty: Medium"},{"edit-time:":1614171257619,"uid":"ROYtZMgHRRE","string":"Topics: math"}]},{"edit-time:":1614171257619,"uid":"gZ9dfLXF8En","string":"**Problem:**","children":[{"edit-time:":1614171257619,"uid":"PscJMcmMQDv","string":"```clojure\n; Write a function which returns a sequence of digits of a non-negative number (first argument) in numerical system with an arbitrary base (second argument).\n; Digits should be represented with their integer values, e.\n; g.\n; 15 would be [1 5] in base 10, [1 1 1 1] in base 2 and [15] in base 16.\n\n(= [1 2 3 4 5 0 1] (__ 1234501 10))\n\n\t\n(= [0] (__ 0 11))\n\n\t\n(= [1 0 0 1] (__ 9 2))\n\n\t\n(= [1 0] (let [n (rand-int 100000)](__ n n)))\n\n\t\n(= [16 18 5 24 15 1] (__ Integer/MAX_VALUE 42))```"}]}],"title":"4clojure - Problem 137"},{"create-time":1614171257619,"edit-time:":1614171257619,"uid":"8EHopIx7HvQ","children":[{"edit-time:":1614171257619,"uid":"PXLKGbm1ziY","string":"**URL:** https://www.4clojure.com/problem/138"},{"edit-time:":1614171257619,"uid":"7ATA9de-CDh","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257619,"uid":"txCpUNuvkTZ","string":"Difficulty: Hard"},{"edit-time:":1614171257619,"uid":"9IPblLDA0MN","string":"Topics: data-juggling"}]},{"edit-time:":1614171257619,"uid":"Inzgah-D7de","string":"**Problem:**","children":[{"edit-time:":1614171257619,"uid":"VimClWa5vQ_","string":"```clojure\n; Create a function of two integer arguments: the start and end, respectively.\n; You must create a vector of strings which renders a 45° rotated square of integers which are successive squares from the start point up to and including the end point.\n; If a number comprises multiple digits, wrap them around the shape individually.\n; If there are not enough digits to complete the shape, fill in the rest with asterisk characters.\n; The direction of the drawing should be clockwise, starting from the center of the shape and working outwards, with the initial direction being down and to the right.\n\n(= (__ 2 2) [\"2\"])\n\n\t\n(= (__ 2 4) [\" 2 \"\n             \"* 4\"\n             \" * \"])\n\n\t\n(= (__ 3 81) [\" 3 \"\n              \"1 9\"\n              \" 8 \"])\n\n\t\n(= (__ 4 20) [\" 4 \"\n              \"* 1\"\n              \" 6 \"])\n\n\t\n(= (__ 2 256) [\"  6  \"\n               \" 5 * \"\n               \"2 2 *\"\n               \" 6 4 \"\n               \"  1  \"])\n\n\t\n(= (__ 10 10000) [\"   0   \"\n                  \"  1 0  \"\n                  \" 0 1 0 \"\n                  \"* 0 0 0\"\n                  \" * 1 * \"\n                  \"  * *  \"\n                  \"   *   \"])```"}]}],"title":"4clojure - Problem 138"},{"create-time":1614171257619,"edit-time:":1614171257619,"uid":"pliFXU50UTI","children":[{"edit-time:":1614171257619,"uid":"tmj--fJ6fq_","string":"**URL:** https://www.4clojure.com/problem/140"},{"edit-time:":1614171257619,"uid":"heAzMBm4JS7","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257619,"uid":"coV6WIJu3Oa","string":"Difficulty: Hard"},{"edit-time:":1614171257619,"uid":"yTNNEOXTsLJ","string":"Topics: math circuit-design"}]},{"edit-time:":1614171257619,"uid":"0OsZ_kxdd_Y","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"IaCBfWB9I16","string":"```clojure\n; Create a function which accepts as input a boolean algebra function in the form of a set of sets, where the inner sets are collections of symbols corresponding to the input boolean variables which satisfy the function (the inputs of the inner sets are conjoint, and the sets themselves are disjoint.\n; also known as canonical minterms).\n; Note: capitalized symbols represent truth, and lower-case symbols represent negation of the inputs.\n; Your function must return the minimal function which is logically equivalent to the input.\n; \n; \n; PS — You may want to give this a read before proceeding: K-Maps\n\n(= (__ #{#{'a 'B 'C 'd}\n         #{'A 'b 'c 'd}\n         #{'A 'b 'c 'D}\n         #{'A 'b 'C 'd}\n         #{'A 'b 'C 'D}\n         #{'A 'B 'c 'd}\n         #{'A 'B 'c 'D}\n         #{'A 'B 'C 'd}})\n   #{#{'A 'c} \n     #{'A 'b}\n     #{'B 'C 'd}})\n\n\t\n(= (__ #{#{'A 'B 'C 'D}\n         #{'A 'B 'C 'd}})\n   #{#{'A 'B 'C}})\n\n\t\n(= (__ #{#{'a 'b 'c 'd}\n         #{'a 'B 'c 'd}\n         #{'a 'b 'c 'D}\n         #{'a 'B 'c 'D}\n         #{'A 'B 'C 'd}\n         #{'A 'B 'C 'D}\n         #{'A 'b 'C 'd}\n         #{'A 'b 'C 'D}})\n   #{#{'a 'c}\n     #{'A 'C}})\n\n\t\n(= (__ #{#{'a 'b 'c} \n         #{'a 'B 'c}\n         #{'a 'b 'C}\n         #{'a 'B 'C}})\n   #{#{'a}})\n\n\t\n(= (__ #{#{'a 'B 'c 'd}\n         #{'A 'B 'c 'D}\n         #{'A 'b 'C 'D}\n         #{'a 'b 'c 'D}\n         #{'a 'B 'C 'D}\n         #{'A 'B 'C 'd}})\n   #{#{'a 'B 'c 'd}\n     #{'A 'B 'c 'D}\n     #{'A 'b 'C 'D}\n     #{'a 'b 'c 'D}\n     #{'a 'B 'C 'D}\n     #{'A 'B 'C 'd}})\n\n\t\n(= (__ #{#{'a 'b 'c 'd}\n         #{'a 'B 'c 'd}\n         #{'A 'B 'c 'd}\n         #{'a 'b 'c 'D}\n         #{'a 'B 'c 'D}\n         #{'A 'B 'c 'D}})\n   #{#{'a 'c}\n     #{'B 'c}})\n\n\t\n(= (__ #{#{'a 'B 'c 'd}\n         #{'A 'B 'c 'd}\n         #{'a 'b 'c 'D}\n         #{'a 'b 'C 'D}\n         #{'A 'b 'c 'D}\n         #{'A 'b 'C 'D}\n         #{'a 'B 'C 'd}\n         #{'A 'B 'C 'd}})\n   #{#{'B 'd}\n     #{'b 'D}})\n\n\t\n(= (__ #{#{'a 'b 'c 'd}\n         #{'A 'b 'c 'd}\n         #{'a 'B 'c 'D}\n         #{'A 'B 'c 'D}\n         #{'a 'B 'C 'D}\n         #{'A 'B 'C 'D}\n         #{'a 'b 'C 'd}\n         #{'A 'b 'C 'd}})\n   #{#{'B 'D}\n     #{'b 'd}})```"}]}],"title":"4clojure - Problem 140"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"hgoefcrcrGr","children":[{"edit-time:":1614171257620,"uid":"FbYDxw4XLmv","string":"**URL:** https://www.4clojure.com/problem/141"},{"edit-time:":1614171257620,"uid":"A9PG3fWAhDd","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"srVijTdyUSa","string":"Difficulty: Medium"},{"edit-time:":1614171257620,"uid":"YMaUBwMhq37","string":"Topics: game cards"}]},{"edit-time:":1614171257620,"uid":"lpLLzD3UdFl","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"aTmpbBWNKxN","string":"```clojure\n; In trick-taking card games such as bridge, spades, or hearts, cards are played in groups known as \"tricks\" - each player plays a single card, in order; the first player is said to \"lead\" to the trick.\n; After all players have played, one card is said to have \"won\" the trick.\n; How the winner is determined will vary by game, but generally the winner is the highest card played in the suit that was led.\n; Sometimes (again varying by game), a particular suit will be designated \"trump\", meaning that its cards are more powerful than any others: if there is a trump suit, and any trumps are played, then the highest trump wins regardless of what was led.\n; \n; \n; Your goal is to devise a function that can determine which of a number of cards has won a trick.\n; You should accept a trump suit, and return a function winner.\n; Winner will be called on a sequence of cards, and should return the one which wins the trick.\n; Cards will be represented in the format returned by Problem 128, Recognize Playing Cards: a hash-map of :suit and a numeric :rank.\n; Cards with a larger rank are stronger.\n\n(let [notrump (__ nil)]\n  (and (= {:suit :club :rank 9}  (notrump [{:suit :club :rank 4}\n                                           {:suit :club :rank 9}]))\n       (= {:suit :spade :rank 2} (notrump [{:suit :spade :rank 2}\n                                           {:suit :club :rank 10}]))))\n\n\t\n(= {:suit :club :rank 10} ((__ :club) [{:suit :spade :rank 2}\n                                       {:suit :club :rank 10}]))\n\n\t\n(= {:suit :heart :rank 8}\n   ((__ :heart) [{:suit :heart :rank 6} {:suit :heart :rank 8}\n                 {:suit :diamond :rank 10} {:suit :heart :rank 4}]))```"}]}],"title":"4clojure - Problem 141"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"2U0rLqPi7iy","children":[{"edit-time:":1614171257620,"uid":"UY39gps2DvA","string":"**URL:** https://www.4clojure.com/problem/143"},{"edit-time:":1614171257620,"uid":"667T0418MJp","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"seUiDFfK_Ln","string":"Difficulty: Easy"},{"edit-time:":1614171257620,"uid":"Gw0BRDngAKs","string":"Topics: seqs math"}]},{"edit-time:":1614171257620,"uid":"XlQpgsJ894w","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"6wMyKtf3JdL","string":"```clojure\n; Create a function that computes the dot product of two sequences.\n; You may assume that the vectors will have the same length.\n\n(= 0 (__ [0 1 0] [1 0 0]))\n\n\t\n(= 3 (__ [1 1 1] [1 1 1]))\n\n\t\n(= 32 (__ [1 2 3] [4 5 6]))\n\n\t\n(= 256 (__ [2 5 6] [100 10 1]))```"}]}],"title":"4clojure - Problem 143"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"yDt_rXZ1oKm","children":[{"edit-time:":1614171257620,"uid":"092GXYpTE9Z","string":"**URL:** https://www.4clojure.com/problem/144"},{"edit-time:":1614171257620,"uid":"RF5S95rEQOR","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"qSL7eJ0t3dT","string":"Difficulty: Medium"},{"edit-time:":1614171257620,"uid":"0mT7eJpCySV","string":"Topics: sequences"}]},{"edit-time:":1614171257620,"uid":"zoSywBpVE-i","string":"**Syntax**:","children":[{"edit-time:":1614171257620,"uid":"u_a6TyAEurH","string":"```clojure\n(int ...)```"},{"edit-time:":1614171257620,"uid":"L6s9lyUHQlk","string":"```clojure\n(double ...)```"}]},{"edit-time:":1614171257620,"uid":"ALAljz1GTXp","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"-U0uOj82yBf","string":"```clojure\n; Write an oscillating iterate: a function that takes an initial value and a variable number of functions.\n; It should return a lazy sequence of the functions applied to the value in order, restarting from the first function after it hits the end.\n\n(= (take 3 (__ 3.14 int double)) [3.14 3 3.0])\n\n\t\n(= (take 5 (__ 3 #(- % 3) #(+ 5 %))) [3 0 5 2 7])\n\n\t\n(= (take 12 (__ 0 inc dec inc dec inc)) [0 1 0 1 0 1 2 1 2 1 2 3])```"}]}],"title":"4clojure - Problem 144"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"62WVBtai0v0","children":[{"edit-time:":1614171257620,"uid":"kNGoaQEyj3F","string":"**URL:** https://www.4clojure.com/problem/145"},{"edit-time:":1614171257620,"uid":"gyekB1_Xqto","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"Regl6Kv5Nwe","string":"Difficulty: Elementary"},{"edit-time:":1614171257620,"uid":"PHNf2_Py1NK","string":"Topics: core-functions seqs"}]},{"edit-time:":1614171257620,"uid":"SVkz-R1e1Yp","string":"**Syntax**:","children":[{"edit-time:":1614171257620,"uid":"XLSvCgHEVol","string":"```clojure\n(partition ...)```"}]},{"edit-time:":1614171257620,"uid":"-hTZjULrQcA","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"ukxziPabkDe","string":"```clojure\n; Clojure's for macro is a tremendously versatile mechanism for producing a sequence based on some other sequence(s).\n; It can take some time to understand how to use it properly, but that investment will be paid back with clear, concise sequence-wrangling later.\n; With that in mind, read over these for expressions and try to see how each of them produces the same result.\n\n(= __ (for [x (range 40)\n            :when (= 1 (rem x 4))]\n        x))\n\n\t\n(= __ (for [x (iterate #(+ 4 %) 0)\n            :let [z (inc x)]\n            :while (< z 40)]\n        z))\n\n\t\n(= __ (for [[x y] (partition 2 (range 20))]\n        (+ x y)))```"}]}],"title":"4clojure - Problem 145"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"hrt7Ai-k6nS","children":[{"edit-time:":1614171257620,"uid":"9TKlQFUTNr7","string":"**URL:** https://www.4clojure.com/problem/146"},{"edit-time:":1614171257620,"uid":"tw0mOlRAjg9","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"xKtxBRoIixX","string":"Difficulty: Easy"},{"edit-time:":1614171257620,"uid":"Mh4UFSkPoLs","string":"Topics: seqs maps"}]},{"edit-time:":1614171257620,"uid":"wIpzSpKMRw_","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"_ip7vtvjMIs","string":"```clojure\n; Because Clojure's for macro allows you to \"walk\" over multiple sequences in a nested fashion, it is excellent for transforming all sorts of sequences.\n; If you don't want a sequence as your final output (say you want a map), you are often still best-off using for, because you can produce a sequence and feed it into a map, for example.\n; \n; \n; For this problem, your goal is to \"flatten\" a map of hashmaps.\n; Each key in your output map should be the \"path\"1 that you would have to take in the original map to get to a value, so for example {1 {2 3}} should result in {[1 2] 3}.\n; You only need to flatten one level of maps: if one of the values is a map, just leave it alone.\n; \n; \n; 1 That is, (get-in original [k1 k2]) should be the same as (get result [k1 k2])\n\n(= (__ '{a {p 1, q 2}\n         b {m 3, n 4}})\n   '{[a p] 1, [a q] 2\n     [b m] 3, [b n] 4})\n\n\t\n(= (__ '{[1] {a b c d}\n         [2] {q r s t u v w x}})\n   '{[[1] a] b, [[1] c] d,\n     [[2] q] r, [[2] s] t,\n     [[2] u] v, [[2] w] x})\n\n\t\n(= (__ '{m {1 [a b c] 3 nil}})\n   '{[m 1] [a b c], [m 3] nil})```"}]}],"title":"4clojure - Problem 146"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"LBQVTRJm4dg","children":[{"edit-time:":1614171257620,"uid":"8C6Dc8lVxUq","string":"**URL:** https://www.4clojure.com/problem/147"},{"edit-time:":1614171257620,"uid":"HqvLf12ARhu","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"T-JdIXrtHY2","string":"Difficulty: Easy"},{"edit-time:":1614171257620,"uid":"4-egYPaGQFl","string":"Topics: seqs"}]},{"edit-time:":1614171257620,"uid":"F3QCeoij9-i","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"MOP4wYNtvtL","string":"```clojure\n; Write a function that, for any given input vector of numbers, returns an infinite lazy sequence of vectors, where each next one is constructed from the previous following the rules used in Pascal's Triangle.\n; For example, for [3 1 2], the next row is [3 4 3 2].\n; \n; \n; Beware of arithmetic overflow! In clojure (since version 1.\n; 3 in 2011), if you use an arithmetic operator like + and the result is too large to fit into a 64-bit integer, an exception is thrown.\n; You can use +' to indicate that you would rather overflow into Clojure's slower, arbitrary-precision bigint.\n\n(= (second (__ [2 3 2])) [2 5 5 2])\n\n\t\n(= (take 5 (__ [1])) [[1] [1 1] [1 2 1] [1 3 3 1] [1 4 6 4 1]])\n\n\t\n(= (take 2 (__ [3 1 2])) [[3 1 2] [3 4 3 2]])\n\n\t\n(= (take 100 (__ [2 4 2])) (rest (take 101 (__ [2 2]))))```"}]}],"title":"4clojure - Problem 147"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"7G9-UadUt-3","children":[{"edit-time:":1614171257620,"uid":"xP7Qr24K67I","string":"**URL:** https://www.4clojure.com/problem/148"},{"edit-time:":1614171257620,"uid":"7P1OX0-Somw","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"6MAuoD3tpzF","string":"Difficulty: Medium"},{"edit-time:":1614171257620,"uid":"7qsO2cJ43l7","string":"Topics: math"}]},{"edit-time:":1614171257620,"uid":"AqhCMU3JHal","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"OQm_IGTQUiu","string":"```clojure\n; Write a function which calculates the sum of all natural numbers under n (first argument) which are evenly divisible by at least one of a and b (second and third argument).\n; Numbers a and b are guaranteed to be coprimes.\n; \n; \n; Note: Some test cases have a very large n, so the most obvious solution will exceed the time limit.\n\n(= 0 (__ 3 17 11))\n\n\t\n(= 23 (__ 10 3 5))\n\n\t\n(= 233168 (__ 1000 3 5))\n\n\t\n(= \"2333333316666668\" (str (__ 100000000 3 5)))\n\n\t\n(= \"110389610389889610389610\"\n  (str (__ (* 10000 10000 10000) 7 11)))\n\n\t\n(= \"1277732511922987429116\"\n  (str (__ (* 10000 10000 10000) 757 809)))\n\n\t\n(= \"4530161696788274281\"\n  (str (__ (* 10000 10000 1000) 1597 3571)))```"}]}],"title":"4clojure - Problem 148"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"t3L27BU0jUD","children":[{"edit-time:":1614171257620,"uid":"1CGJXggB35a","string":"**URL:** https://www.4clojure.com/problem/150"},{"edit-time:":1614171257620,"uid":"mamZAkjPOtu","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"oHudT16hAvY","string":"Difficulty: Medium"},{"edit-time:":1614171257620,"uid":"qSbIZbe_Gir","string":"Topics: seqs math"}]},{"edit-time:":1614171257620,"uid":"vbj9CqZY6H4","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"v2UvC6cMzp3","string":"```clojure\n; A palindromic number is a number that is the same when written forwards or backwards (e.\n; g.\n; , 3, 99, 14341).\n; \n; \n; Write a function which takes an integer n, as its only argument, and returns an increasing lazy sequence of all palindromic numbers that are not less than n.\n; \n; The most simple solution will exceed the time limit!\n\n(= (take 26 (__ 0))\n   [0 1 2 3 4 5 6 7 8 9 \n    11 22 33 44 55 66 77 88 99 \n    101 111 121 131 141 151 161])\n\n\t\n(= (take 16 (__ 162))\n   [171 181 191 202 \n    212 222 232 242 \n    252 262 272 282 \n    292 303 313 323])\n\n\t\n(= (take 6 (__ 1234550000))\n   [1234554321 1234664321 1234774321 \n    1234884321 1234994321 1235005321])\n\n\t\n(= (first (__ (* 111111111 111111111)))\n   (* 111111111 111111111))\n\n\t\n(= (set (take 199 (__ 0)))\n   (set (map #(first (__ %)) (range 0 10000))))\n\n\t\n(= true \n   (apply < (take 6666 (__ 9999999))))\n\n\t\n(= (nth (__ 0) 10101)\n   9102019)```"}]}],"title":"4clojure - Problem 150"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"BKQygg7nCkc","children":[{"edit-time:":1614171257620,"uid":"sxvx3SP7PUP","string":"**URL:** https://www.4clojure.com/problem/152"},{"edit-time:":1614171257620,"uid":"40AC1G0528X","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"csHt-pMrNbs","string":"Difficulty: Hard"},{"edit-time:":1614171257620,"uid":"pX0g7O36TM6","string":"Topics: data-analysis math"}]},{"edit-time:":1614171257620,"uid":"FetfO2aQ9oE","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"pP0nsZxpeNj","string":"```clojure\n; A Latin square of order n is an n x n array that contains n different elements, each occurring exactly once in each row, and exactly once in each column.\n; For example, among the following arrays only the first one forms a Latin square:.\n; \n; \n; 1\n; 2\n; 3\n; 4\n; A B C    A B C    A B C\n; B C A    B C A    B D A\n; C A B    C A C    C A B\n;  \n; \n; Let V be a vector of such vectors1 that they may differ in length2.\n; We will say that an arrangement of vectors of V in consecutive rows is an alignment (of vectors) of V if the following conditions are satisfied:.\n; \n; \n; All vectors of V are used.\n; Each row contains just one vector.\n; The order of V is preserved.\n; All vectors of maximal length are horizontally aligned each other.\n; If a vector is not of maximal length then all its elements are aligned with elements of some subvector of a vector of maximal length.\n; Let L denote a Latin square of order 2 or greater.\n; We will say that L is included in V or that V includes L iff there exists an alignment of V such that contains a subsquare that is equal to L.\n; \n; \n; For example, if V equals [[1 2 3][2 3 1 2 1][3 1 2]] then there are nine alignments of V (brackets omitted):\n; \n; 1\n; 2\n; 3\n; 4\n; 5\n; 6\n; 7\n; 8\n; 9\n; 10\n; 11\n; 12\n; 13\n; 14\n; 15\n;  \n;         1              2              3\n;  \n;       1 2 3          1 2 3          1 2 3\n;   A   2 3 1 2 1    2 3 1 2 1    2 3 1 2 1\n;       3 1 2        3 1 2        3 1 2\n;  \n;       1 2 3          1 2 3          1 2 3\n;   B   2 3 1 2 1    2 3 1 2 1    2 3 1 2 1\n;         3 1 2        3 1 2        3 1 2\n;  \n;       1 2 3          1 2 3          1 2 3\n;   C   2 3 1 2 1    2 3 1 2 1    2 3 1 2 1\n;           3 1 2        3 1 2        3 1 2\n;  \n; Alignment A1 contains Latin square [[1 2 3][2 3 1][3 1 2]], alignments A2, A3, B1, B2, B3 contain no Latin squares, and alignments C1, C2, C3 contain [[2 1][1 2]].\n; Thus in this case V includes one Latin square of order 3 and one of order 2 which is included three times.\n; \n; \n; Our aim is to implement a function which accepts a vector of vectors V as an argument, and returns a map which keys and values are integers.\n; Each key should be the order of a Latin square included in V, and its value a count of different Latin squares of that order included in V.\n; If V does not include any Latin squares an empty map should be returned.\n; In the previous example the correct output of such a function is {3 1, 2 1} and not {3 1, 2 3}.\n; \n; \n; 1 Of course, we can consider sequences instead of vectors.\n; 2 Length of a vector is the number of elements in the vector.\n\n(= (__ '[[A B C D]\n         [A C D B]\n         [B A D C]\n         [D C A B]])\n   {})\n\n\t\n(= (__ '[[A B C D E F]\n         [B C D E F A]\n         [C D E F A B]\n         [D E F A B C]\n         [E F A B C D]\n         [F A B C D E]])\n   {6 1})\n\n\t\n(= (__ '[[A B C D]\n         [B A D C]\n         [D C B A]\n         [C D A B]])\n   {4 1, 2 4})\n\n\t\n(= (__ '[[B D A C B]\n         [D A B C A]\n         [A B C A B]\n         [B C A B C]\n         [A D B C A]])\n   {3 3})\n\n\t\n(= (__ [  [2 4 6 3]\n        [3 4 6 2]\n          [6 2 4]  ])\n   {})\n\n\t\n(= (__ [[1]\n        [1 2 1 2]\n        [2 1 2 1]\n        [1 2 1 2]\n        []       ])\n   {2 2})\n\n\t\n(= (__ [[3 1 2]\n        [1 2 3 1 3 4]\n        [2 3 1 3]    ])\n   {3 1, 2 2})\n\n\t\n(= (__ [[8 6 7 3 2 5 1 4]\n        [6 8 3 7]\n        [7 3 8 6]\n        [3 7 6 8 1 4 5 2]\n              [1 8 5 2 4]\n              [8 1 2 4 5]])\n   {4 1, 3 1, 2 7})```"}]}],"title":"4clojure - Problem 152"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"uNLzE32LX-i","children":[{"edit-time:":1614171257620,"uid":"LFaRXLlAtmR","string":"**URL:** https://www.4clojure.com/problem/153"},{"edit-time:":1614171257620,"uid":"oVXCW99DGR2","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"Q7gHVeTsAA9","string":"Difficulty: Easy"},{"edit-time:":1614171257620,"uid":"BX9sEL4tZF2","string":"Topics: set-theory"}]},{"edit-time:":1614171257620,"uid":"RwJLvoCyx4Z","string":"**Syntax**:","children":[{"edit-time:":1614171257620,"uid":"Vrwiu3426Ui","string":"```clojure\n(symbol ...)```"},{"edit-time:":1614171257620,"uid":"2t6AFte2SEo","string":"```clojure\n(keyword ...)```"},{"edit-time:":1614171257620,"uid":"zjUOrk29AZd","string":"```clojure\n(mapcat ...)```"},{"edit-time:":1614171257620,"uid":"6E_a7WVFvV_","string":"```clojure\n(comment ...)```"}]},{"edit-time:":1614171257620,"uid":"ATj9PMWkzeB","string":"**Problem:**","children":[{"edit-time:":1614171257620,"uid":"GfHmFGJin-u","string":"```clojure\n; Given a set of sets, create a function which returns true if no two of those sets have any elements in common1 and false otherwise.\n; Some of the test cases are a bit tricky, so pay a little more attention to them.\n; \n; \n; 1Such sets are usually called pairwise disjoint or mutually disjoint.\n\n(= (__ #{#{\\U} #{\\s} #{\\e \\R \\E} #{\\P \\L} #{\\.}})\n   true)\n\n\t\n(= (__ #{#{:a :b :c :d :e}\n         #{:a :b :c :d}\n         #{:a :b :c}\n         #{:a :b}\n         #{:a}})\n   false)\n\n\t\n(= (__ #{#{[1 2 3] [4 5]}\n         #{[1 2] [3 4 5]}\n         #{[1] [2] 3 4 5}\n         #{1 2 [3 4] [5]}})\n   true)\n\n\t\n(= (__ #{#{'a 'b}\n         #{'c 'd 'e}\n         #{'f 'g 'h 'i}\n         #{''a ''c ''f}})\n   true)\n\n\t\n(= (__ #{#{'(:x :y :z) '(:x :y) '(:z) '()}\n         #{#{:x :y :z} #{:x :y} #{:z} #{}}\n         #{'[:x :y :z] [:x :y] [:z] [] {}}})\n   false)\n\n\t\n(= (__ #{#{(= \"true\") false}\n         #{:yes :no}\n         #{(class 1) 0}\n         #{(symbol \"true\") 'false}\n         #{(keyword \"yes\") ::no}\n         #{(class '1) (int \\0)}})\n   false)\n\n\t\n(= (__ #{#{distinct?}\n         #{#(-> %) #(-> %)}\n         #{#(-> %) #(-> %) #(-> %)}\n         #{#(-> %) #(-> %) #(-> %)}})\n   true)\n\n\t\n(= (__ #{#{(#(-> *)) + (quote mapcat) #_ nil}\n         #{'+ '* mapcat (comment mapcat)}\n         #{(do) set contains? nil?}\n         #{, , , #_, , empty?}})\n   false)```"}]}],"title":"4clojure - Problem 153"},{"create-time":1614171257620,"edit-time:":1614171257620,"uid":"4r3nZmeKPhq","children":[{"edit-time:":1614171257620,"uid":"HUbemPVZpxh","string":"**URL:** https://www.4clojure.com/problem/156"},{"edit-time:":1614171257620,"uid":"-eNrtarM0T5","string":"**Problem-Tags**:","children":[{"edit-time:":1614171257620,"uid":"2J1howImD6i","string":"Difficulty: Elementary"},{"edit-time:":1614171257620,"uid":"5rDNtxj4RJp","string":"Topics: seqs"}]},{"edit-time:":1614171257621,"uid":"l5QexDifj9Y","string":"**Problem:**","children":[{"edit-time:":1614171257621,"uid":"VdcHA9gz-dk","string":"```clojure\n; When retrieving values from a map, you can specify default values in case the key is not found:\n\n(= 2 (:foo {:bar 0, :baz 1} 2))\n\nHowever, what if you want the map itself to contain the default values? Write a function which takes a default value and a sequence of keys and constructs a map.\n\n\t\n(= (__ 0 [:a :b :c]) {:a 0 :b 0 :c 0})\n\n\t\n(= (__ \"x\" [1 2 3]) {1 \"x\" 2 \"x\" 3 \"x\"})\n\n\t\n(= (__ [:a :b] [:foo :bar]) {:foo [:a :b] :bar [:a :b]})```"}]}],"title":"4clojure - Problem 156"}]